'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const javascriptTypes = [Number, Boolean, String, Object, Array];

const isJavascriptType = type => {
  return javascriptTypes.includes(type);
};

const valueOfType = (type, val) => {
  if (type === Number) {
    return val instanceof Number || typeof val === 'number';
  }
  if (type === Boolean) {
    return val instanceof Boolean || typeof val === 'boolean';
  }
  if (type === String) {
    return val instanceof String || typeof val === 'string';
  }
  if (type === Object) {
    return val instanceof Object || typeof val === 'object';
  }
  if (type === Array) {
    return val instanceof Array;
  }
};

const validValidatorReturn = val => {
  if (typeof val === 'object') {
    if (typeof val['status'] === 'boolean' && (val['status'] || typeof val['error'] === 'string')) {
      return true;
    }
  }
  return false;
};

exports.default = async config => {
  if (typeof config !== 'object') {
    throw new Error('Parser generator 1º argument must be a object');
  }
  for (let key in config) {
    const field = config[key];
    if (typeof field !== 'object') {
      throw new Error(`Type of field ${key} must be a object`);
    }
    if (typeof field['required'] !== 'boolean') {
      throw new Error(`Field`);
    }

    if (typeof field['type'] === 'function') {
      if (isJavascriptType(field['type'])) {
        field['type'] = [field['type']];
      } else {
        throw new Error(`${field['type']} is not a javascript type in field ${key}`);
      }
    } else if (field['type'] instanceof Array) {
      for (let type of field['type']) {
        if (!isJavascriptType(type)) {
          throw new Error(`${type} is not a javascript type in field ${key}`);
        }
      }
    } else {
      throw new Error(`Field must have a field 'type' of javascript type or a array of javascript types`);
    }
    if (typeof field['validator'] === 'undefined') {
      field['validator'] = async () => {
        return { status: true };
      };
    }
    if (!(field['validator'] instanceof Function)) {
      throw new Error(`Field ${key} validator must be of type function`);
    } else {
      const exec = await field['validator'](null);
      if (!validValidatorReturn(exec)) {
        throw new Error(`Field ${key} Validator function must have function that return a Object '{ status: Boolean, error: 'String'}'`);
      }
      field['isValid'] = async val => {
        let validType = false;
        for (let type of field['type']) {
          validType = valueOfType(type, val) || validType;
        }
        if (!validType) {
          return { status: false, error: 'invalid-type' };
        } else {
          return field['validator'](val);
        }
      };
    }
  }
  const clean = async record => {
    // TODO: Marco
  };

  const validate = async (record, ignored) => {
    // 1 º Test if all fields in record exist in config
    // 2 º Test if all required fields in config exist in record
    // 3 º Test if the domain of all fields is valid
    const validation = {
      status: true,
      fields: {}
    };

    for (let key in record) {
      if (key === 'metadata') {
        continue;
      }

      if (ignored.includes(key)) {
        continue;
      }

      if (config[key] === undefined) {
        // 1ª
        validation.fields[key] = { type: 'not-in-schema', error: 'not-in-schema' };
        validation.status = false;
      } else {
        // 3º
        const result = await config[key].isValid(record[key]);
        if (!result.status) {
          validation.fields[key] = { type: 'invalid-domain', error: result.error };
          validation.status = false;
        }
      }
    }
    // 2º
    for (let key in config) {
      if (ignored.includes(key)) {
        continue;
      }
      if (config[key].required) {
        if (record[key] === undefined) {
          validation.fields[key] = { type: 'required-in-schema', error: 'required-in-schema' };
          validation.status = false;
        }
      }
    }
    return validation;
  };

  const fields = Object.keys(config);

  return {
    clean,
    validate,
    fields
  };
};

module.exports = exports['default'];