'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
const keysNotInObject = (keys, obj) => {
  return Object.keys(obj).filter(f => !keys.includes(f));
};

const templateTypes = exports.templateTypes = ['article', 'book', 'booklet', 'inbook', 'incollection', 'inproceedings', 'manual', 'mastersthesis', 'misc', 'phdthesis', 'patent', 'prize', 'proceedings', 'techreport', 'unpublished'];

const userValidation = ({ requiredUserId, val }) => {
  let countUserIds = 0;
  if (!(val instanceof Array)) {
    return { status: false, error: 'author-must-be-array' };
  }
  for (const el of val) {
    if (el === null) {
      return { status: false, error: 'null-not-allowed' };
    }
    const notKeys = keysNotInObject(['name', 'userId'], el);
    if (notKeys.length > 0) {
      return { status: false, error: 'extra-keys-not-alowed' };
    }
    if (typeof el['name'] !== 'string') {
      return { status: false, error: 'required-name-field-has-string' };
    }
    if (el['userId']) {
      if (typeof el['userId'] !== 'string') {
        return { status: false, error: 'userId-field-has-string' };
      } else {
        countUserIds += 1;
      }
    }
  }

  if (requiredUserId && countUserIds === 0) {
    return { status: false, error: 'at-least-one-userid' };
  }

  return { status: true };
};

exports.default = {
  title: async val => {
    return { status: true };
  },
  abstract: async val => {
    return { status: true };
  },
  author: async val => {
    return userValidation({ requiredUserId: false, val });
  },
  authorWithAtLeastOneLink: async val => {
    return userValidation({ requiredUserId: true, val });
  },
  year: async val => {
    return val > 1900 && val < 2100 ? { status: true } : { status: false, error: 'value-between-1900-and-2100' };
  },
  journal: async val => {
    return { status: true };
  },
  volume: async val => {
    return { status: true };
  },
  number: async val => {
    return { status: true };
  },
  pages: async val => {
    return { status: true };
  },
  month: async val => {
    return { status: true };
  },
  doi: async val => {
    return { status: true };
  },
  isbn: async val => {
    return { status: true };
  },
  issn: async val => {
    return { status: true };
  },
  keyword: async val => {
    return { status: true };
  },
  editor: async val => {
    return userValidation({ requiredUserId: false, val });
  },
  editorWithAtLeastOneLink: async val => {
    return userValidation({ requiredUserId: true, val });
  },
  advisors: async val => {
    return userValidation({ requiredUserId: false, val });
  },
  advisorsWithAtLeastOneLink: async val => {
    return userValidation({ requiredUserId: true, val });
  },
  publisher: async val => {
    return { status: true };
  },
  series: async val => {
    return { status: true };
  },
  address: async val => {
    return { status: true };
  },
  edition: async val => {
    return { status: true };
  },
  url: async val => {
    return { status: true };
  },
  howpublished: async val => {
    return { status: true };
  },
  chapter: async val => {
    return { status: true };
  },
  type: async val => {
    return { status: true };
  },
  booktitle: async val => {
    return { status: true };
  },
  organization: async val => {
    return { status: true };
  },
  institution: async val => {
    return { status: true };
  },
  school: async val => {
    return { status: true };
  },
  reference: async val => {
    return { status: true };
  },
  date: async val => {
    return { status: true };
  },
  aprovaldate: async val => {
    return { status: true };
  },
  registrationdate: async val => {
    return { status: true };
  },
  location: async val => {
    return { status: true };
  },
  patentstatus: async val => {
    return { status: true };
  },
  event: async val => {
    return { status: true };
  },
  tid: async val => {
    return { status: true };
  },
  template: async val => {
    if (templateTypes.includes(val)) {
      return { status: true };
    } else {
      return { status: false, error: 'template-not-allowed' };
    }
  }
};