'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.consoleFormat = exports.levels = exports.configLogger = exports.logger = undefined;

var _winston = require('winston');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _winstonDailyRotateFile = require('winston-daily-rotate-file');

var _winstonDailyRotateFile2 = _interopRequireDefault(_winstonDailyRotateFile);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _winstonTransport = require('winston-transport');

var _winstonTransport2 = _interopRequireDefault(_winstonTransport);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _stripAnsi = require('strip-ansi');

var _stripAnsi2 = _interopRequireDefault(_stripAnsi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let modernSyslog;

if (!/^win/i.test(process.platform)) {
  modernSyslog = require('modern-syslog');
}

let $logger = {
  log: () => {
    throw new Error('You need to call configLogger(config), before using logger');
  }
};

const levels = {
  emerg: 0,
  alert: 1,
  crit: 2,
  err: 3,
  warn: 4,
  notice: 5,
  info: 6,
  debug: 7
};

class SyslogTransport extends _winstonTransport2.default {
  constructor(opts) {
    super(opts);
    modernSyslog && modernSyslog.open(opts.ident, {}, modernSyslog.LOG_LOCAL0);
  }
  log(info, callback) {
    setImmediate(() => {
      this.emit('logged', info);
    });
    const level = levels[info.level] === undefined ? 3 : levels[info.level];
    modernSyslog && modernSyslog.log(level, info.message, callback);
  }
}

const consoleFormat = {
  convertToString(message) {
    let msg = '';
    if (message.tags) {
      msg = '[';
      for (let n = 0; n < message.tags.length; ++n) {
        msg += ` ${message.tags[n]}`;
        if (n + 1 !== message.tags.length) {
          msg += ',';
        }
      }
      msg += ' ]';
      msg = _chalk2.default.bold.italic(msg);
    } else if (message.logLevel) {
      try {
        msg = _chalk2.default.bold(`[ ${message.logLevel} ]`);
      } catch (error) {
        console.log(error);
      }
    }
    if (message.ctx) {
      if (message.ctx.log) {
        if (message.ctx.log.origin && message.ctx.log.service) {
          msg += ` ${message.ctx.log.origin} in ${message.ctx.log.service} â†¦`;
          if (message.logLevel) {
            try {
              msg = _chalk2.default.bold(msg);
            } catch (error) {
              console.log(error);
            }
          }
        }
      }
    }
    msg += ` ${message.msg}`;
    for (let key in message.ctx) {
      if (key !== 'log') {
        msg += `${_os2.default.EOL}${key}: ${JSON.stringify(message.ctx[key], null, 2)}`;
      }
    }
    return msg;
  },
  convertToJSON(message) {
    const json = {};
    message = (0, _stripAnsi2.default)(message);
    let tags = message.match(/\[ (.*) \]/)[1];
    tags = tags.split(', ');
    json.tags = tags;
    const match = message.match(/\[ .*\] (.*)/);
    json.msg = match[1];
    const ctxLines = message.substring(match[0].length + _os2.default.EOL.length);
    if (ctxLines) {
      let ctxArray = ctxLines.match(/^ {3}(.*)$/gm);
      const ctx = {};
      ctxArray = ctxArray.map(c => c.substring(4));
      for (let el of ctxArray) {
        el = el.split(': ');
        ctx[el[0]] = el[1];
      }
      json.ctx = ctx;
    }
    return json;
  }
};

class ConsoleTransport extends _winstonTransport2.default {
  log(info, callback) {
    setImmediate(() => {
      this.emit('logged', info);
    });
    const message = JSON.parse(info.message);
    switch (info.level) {
      case 'emerg':
        console.log(_chalk2.default.redBright(consoleFormat.convertToString(message)));
        break;
      case 'alert':
        console.log(_chalk2.default.redBright(consoleFormat.convertToString(message)));
        break;
      case 'crit':
        console.log(_chalk2.default.red(consoleFormat.convertToString(message)));
        break;
      case 'err':
        console.log(_chalk2.default.red(consoleFormat.convertToString(message)));
        break;
      case 'warn':
        console.log(_chalk2.default.yellowBright(consoleFormat.convertToString(message)));
        break;
      case 'notice':
        console.log(_chalk2.default.yellow(consoleFormat.convertToString(message)));
        break;
      case 'info':
        console.log(_chalk2.default.green(consoleFormat.convertToString(message)));
        break;
      case 'debug':
        console.log(_chalk2.default.blue(consoleFormat.convertToString(message)));
        break;
      default:
        console.log(_chalk2.default.gray(consoleFormat.convertToString(message)));
    }
    callback();
  }
}

const configLogger = config => {
  const configSchema = {
    loggers: _joi2.default.array().items(_joi2.default.object().keys({
      type: _joi2.default.string().valid(['console', 'file-rotate', 'file', 'syslog']),
      level: _joi2.default.string().valid(Object.keys(levels)).default('info'),
      options: _joi2.default.object().when('type', {
        is: 'console',
        then: _joi2.default.any().forbidden()
      }).when('type', {
        is: 'file',
        then: _joi2.default.object().keys({
          filename: _joi2.default.string().required()
        })
      }).when('type', {
        is: 'file-rotate',
        then: _joi2.default.object().keys({
          datePattern: _joi2.default.string().default('yyyy-MM-dd'),
          filename: _joi2.default.string().required()
        })
      }).when('type', {
        is: 'syslog',
        then: _joi2.default.object().keys({
          ident: _joi2.default.string().default('node-app')
        })
      })
    })).default([])
  };

  const validation = _joi2.default.validate(config, configSchema, { allowUnknown: true });
  if (validation.error) {
    throw new Error(`Invalid options: ${validation.error}`);
  } else {
    config = validation.value;
  }
  const loggers = config && config.loggers && config.loggers.length > 0 ? config.loggers : [{ type: 'console' }];
  const transportsList = loggers.map(loggerConfig => {
    switch (loggerConfig.type) {
      case 'console':
        return new ConsoleTransport({ level: loggerConfig.level });
      case 'file':
        return new _winston.transports.File({ filename: `${loggerConfig.options.filename}.log`, level: loggerConfig.level });
      case 'file-rotate':
        return new _winstonDailyRotateFile2.default({
          filename: loggerConfig.options.filename + '-%DATE%.log',
          datePattern: loggerConfig.options.datePattern,
          prepend: true,
          level: loggerConfig.logLevel
        });
      case 'syslog':
        return new SyslogTransport({
          level: loggerConfig.level,
          ident: loggerConfig.options.ident
        });
    }
  });
  $logger = (0, _winston.createLogger)({
    levels,
    transports: transportsList
  });
};

const logger = (tags, msg, ctx) => {
  let config = { tags, msg, ctx };

  const oldConfigSchema = _joi2.default.object().keys({
    tags: _joi2.default.array().items(_joi2.default.string()).required(),
    msg: _joi2.default.string().required(),
    ctx: _joi2.default.object()
  });
  const configSchema = _joi2.default.object().keys({
    level: _joi2.default.string().valid(['emerg', 'alert', 'crit', 'err', 'warn', 'notice', 'info', 'debug']).required(),
    msg: _joi2.default.string().required(),
    ctx: _joi2.default.object().required()
  });
  let validation = _joi2.default.validate(config, oldConfigSchema);
  if (!validation.error) {
    const message = validation.value;
    const intersection = _underscore2.default.intersection(tags, Object.keys(levels));
    let selectedLogger;
    if (intersection.length === 0) {
      selectedLogger = 'debug';
    } else if (intersection.length > 1) {
      $logger.log({
        level: 'warn',
        message: JSON.stringify({
          tags: ['papagaio', 'warn'],
          message: `Log levels conflict ${intersection} when logged withs: ${tags}. Using ${intersection[0]}`
        })
      });
      selectedLogger = intersection[0];
    } else {
      selectedLogger = intersection[0];
    }

    return $logger.log({ level: selectedLogger, message: JSON.stringify(message) });
  }
  config = { level: tags, msg, ctx };
  validation = _joi2.default.validate(config, configSchema);
  if (!validation.error) {
    const message = validation.value;
    message.logLevel = config.level;
    return $logger.log({ level: config.level, message: JSON.stringify(message) });
  }
  return $logger.log({ level: 'warn', message: JSON.stringify({ msg: 'Wrong logger invocation.' }) });
};

exports.logger = logger;
exports.configLogger = configLogger;
exports.levels = levels;
exports.consoleFormat = consoleFormat;