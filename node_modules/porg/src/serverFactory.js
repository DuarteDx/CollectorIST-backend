import hapi from 'hapi'
import processRoutes from '@/routes'
import processPlugins from '@/plugins'
import { hasUserSession, hasStaticBearer, hasStaticBearerKey, hasTwoFactor } from '@/plugins/auth'
import { getUserAuthProvider } from '@/providers'
import fs from 'fs'
import path from 'path'
import Joi from 'joi'
import { logger } from 'papagaio'
import { errorWithKey } from '@/plugins/errors'

let basePath
const createServer = ({config}) => {
  basePath = path.dirname(require.main.filename)
  if (config.nodeStartPath) {
    basePath = path.resolve(basePath, config.nodeStartPath)
  }

  let https = {}
  if (config.application.tls) {
    https = { tls: {
      'key': fs.readFileSync(config.application.tls.key),
      'cert': fs.readFileSync(config.application.tls.cert)
    }}
  }

  const serverOptions = {
    'port': config.application.backendPort,
    'routes': {
      'auth': {
        'strategy': 'dsi-auth',
        'mode': 'required'
      },
      'validate': {
        'failAction': async (request, h, err) => { // Refactor to plugin hapi-papagaio
          // This catches validations errors on all routes of hapi.js and disables the useless stacktrace
          throw errorWithKey('validation-error', { tags: ['warn'], cause: `${err.message}\nRequest Url Path: ${request.url.path}`, stackDisabled: true })
        }
      }
    },
    ...https
  }
  const server = hapi.server(serverOptions)
  return server
}

const processAuthPlugin = async ({config}) => {
  let userAuthProvider
  let auth
  if (config.auth && (config.auth.userSession || config.auth.staticBearer)) {
    auth = {}
    if (config.auth.staticBearer) {
      auth.staticBearer = config.auth.staticBearer
    }

    if (config.auth.userSession) {
      auth.sessionTime = config.auth.userSession.singleSignOn.sessionTime
      auth.unauthorizedPath = config.auth.userSession.unauthorizedPath
      const getClaimsFromAuthenticationContextScriptPath = path.join(basePath, 'services', 'authentication', 'GetClaimsFromAuthenticationContext.js')
      if (!fs.existsSync(getClaimsFromAuthenticationContextScriptPath)) {
        throw new Error(`Missing GetClaimsFromAuthenticationContext script at ${getClaimsFromAuthenticationContextScriptPath}`)
      }
      let localAppUrl = `${config.application.protocol}://${config.application.host}`
      if ((config.application.protocol.toLowerCase() === 'https' && config.application.frontendPort !== 443) ||
        (config.application.protocol.toLowerCase() === 'http' && config.application.frontendPort !== 80)) {
        localAppUrl = `${localAppUrl}:${config.application.frontendPort}`
      }
      if (config.auth.userSession.singleSignOn.type.cas) {
        auth.cas = {
          'serverUrl': config.auth.userSession.singleSignOn.type.cas.serverUrl,
          'localAppUrl': localAppUrl,
          'strictSSL': config.auth.userSession.singleSignOn.type.cas.strictSsl
        }
      } else if (config.auth.userSession.singleSignOn.type.saml) {
        auth.saml = {
          ...config.auth.userSession.singleSignOn.type.saml,
          'localAppUrl': localAppUrl
        }
      } else {
        throw new Error('No authentication mechanism (CAS or SAML) configured.')
      }

      auth.jwt = {
        'getPayloadForUsername': require(getClaimsFromAuthenticationContextScriptPath),
        'secret': config.auth.userSession.singleSignOn.jwt.secret
      }
      if (config.auth.userSession.twoFactor) {
        userAuthProvider = getUserAuthProvider({name: config.auth.userSession.twoFactor.persistenceProvider})
        const twoFactor = {
          'sessionTime': config.auth.userSession.twoFactor.sessionTime
        }

        if (config.auth.userSession.twoFactor.modes.includes('u2f')) {
          twoFactor.u2f = {
            'getUserU2F': userAuthProvider.getU2FForUsername,
            'saveUserU2FChallenge': userAuthProvider.createOrUpdateAuthorU2FAuth,
            'upsertUserU2F': userAuthProvider.createOrUpdateAuthorU2FAuthRequest,
            'appId': localAppUrl
          }
        }

        if (config.auth.userSession.twoFactor.modes.includes('totp')) {
          twoFactor.totp = {
            'service': config.application.name,
            'upsertUserTOTP': userAuthProvider.registerTOTPSecretForUsername,
            'confirmUserTOTP': userAuthProvider.confirmTOTPSecretForUsername,
            'getUserTOTP': userAuthProvider.getTOTPForUsername
          }
        }
        auth.twoFactor = twoFactor
      }
    }
  } else {
    auth = {}
  }
  return {
    plugin: require('@/plugins/auth'),
    options: auth
  }
}

const processLoggingPlugin = async ({config}) => {
  const setupApplicationErrorsScriptPath = path.join(basePath, 'errors', 'index.js')
  let setupApplicationErrors
  if (fs.existsSync(setupApplicationErrorsScriptPath)) {
    setupApplicationErrors = require(setupApplicationErrorsScriptPath)
  } else {
    setupApplicationErrors = () => {
      logger(['warn', 'porg'], 'No src/errors/index.js was found, no user errors defined')
    }
  }
  return {
    plugin: require('@/plugins/errors'),
    options: {
      'urlPath': config.errors.localeEndpoint,
      'setupApplicationErrors': setupApplicationErrors,
      'papagaio': config.papagaio
    }
  }
}

const processMetricsPlugin = async ({config}) => {
  return {
    plugin: require('@/plugins/metrics'),
    options: config.metrics,
    routes: {
      prefix: config.metrics.endpoint
    }
  }
}

const processHealthcheckPlugin = async ({config}) => {
  return {
    plugin: require('@/plugins/healthcheck'),
    options: config
  }
}

const porgPluginSchemaObject = Joi.object().keys({
  type: Joi.string().valid('user-session', 'static-bearer', 'no-auth').required(),
  key: Joi.when('type', {is: 'static-bearer', then: Joi.string().required()}),
  roles: Joi.when('type', {is: 'user-session', then: Joi.array().items(Joi.string()).required()}),
  twoFactor: Joi.when('type', {is: 'user-session', then: Joi.boolean()})
})

const porgPluginSchema = Joi.object().keys({
  'porg-auth': Joi.alternatives().try(porgPluginSchemaObject, Joi.array().items(porgPluginSchemaObject)).required()
})

const validatePluginAndRoutes = async (server) => {
  const table = server.table()
  for (let route of table) {
    const validation = Joi.validate(route.settings.plugins, porgPluginSchema)
    if (validation.error) {
      let message = `Error processing porg-auth in path ${route.path} method ${route.method} problem`
      validation.error.details.forEach(e => { message += ` ${e.path[0]} => ${e.type}` })
      throw new Error(message)
    }
    const porgPluginOptions = [].concat(validation.value['porg-auth'])
    if (!hasUserSession()) {
      porgPluginOptions.filter(o => o.type === 'user-session').map(o => { throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'user-session' was not defined in porg.yml`) })
    }
    if (!hasStaticBearer()) {
      porgPluginOptions.filter(o => o.type === 'static-bearer').map(o => { throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'static-bearer' was not defined in porg.yml`) })
    }

    if (hasStaticBearer()) {
      porgPluginOptions
        .filter(o => o.type === 'static-bearer')
        .filter(o => !hasStaticBearerKey(o.key))
        .map(o => { throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'static-bearer' key ${o.key} was not defined in porg.yml`) })
    }

    if (hasUserSession() && !hasTwoFactor()) {
      porgPluginOptions
        .filter(o => o.type === 'user-session' && o.twoFactor !== undefined)
        .map(o => { throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'twoFactor' was not defined in porg.yml`) })
    }
  }
}

export default async ({ config }) => {
  const server = createServer({ config })
  let plugins = []
  plugins.push(await processAuthPlugin({server, config}))
  plugins.push(await processLoggingPlugin({server, config}))
  plugins.push(await processMetricsPlugin({server, config}))
  if (config.auth.userSession) {
    plugins.push(await processHealthcheckPlugin({server, config}))
  }
  plugins = plugins.concat(await processRoutes({ nodeStartPath: config.nodeStartPath }))
  for (let pluginConfig of config.plugins) {
    const plugin = { plugin: require(pluginConfig.name) }
    if (pluginConfig.options) {
      plugin.options = pluginConfig.options
    }
    if (pluginConfig.routes) {
      plugin.routes = pluginConfig.routes
    }
    if (pluginConfig.once) {
      plugin.once = pluginConfig.once
    }
    plugins.push(plugin)
  }
  const internalPlugins = await processPlugins({nodeStartPath: config.nodeStartPath})
  plugins = plugins.concat(internalPlugins)
  await server.register(plugins)
  server.ext({type: 'onPreStart', method: validatePluginAndRoutes})
  return server
}
