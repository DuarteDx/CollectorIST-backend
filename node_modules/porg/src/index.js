import yaml from 'js-yaml'
import serverFactory from '@/serverFactory'
import { runConfigWithDriver, Mongo, Smtp, Elasticsearch } from '@/drivers'
import { setupError, errorWithKey, resetMapErrors } from '@/plugins/errors'
import { logger, configLogger, consoleFormat } from 'papagaio'
import {
  runMigrations,
  loadFile as loadMigrationFile,
  loadFileStream as loadMigrationFileStream
} from '@/migrations'
import { Email } from '@/emails/Email'
import Joi from 'joi'
import configSchema from '@/config/ConfigSchema'
import { configTaskRunner, setupTasksEndpoints, tasks } from '@/tasks'
import emailSetup from '@/emails'
import { storageSetup, Storage } from '@/storage'
import { setupFileUploadHandlers } from '@/file-upload-handlers'
import Task from '@/tasks/Task'
import { mapper } from '@/schemas'
import cluster from 'cluster'
import os from 'os'
import { clientProm } from '@/plugins/metrics'
import StatusCodes from '@/utils/StatusCodes'
import fs from 'fs'
import path from 'path'
import camelcaseKeys from 'camelcase-keys'
import { setSocketIO, getSocketIO } from '@/sockets'
import { getLockProvider } from '@/providers'

process.on('unhandledRejection', error => {
  // Will print "unhandledRejection err is not defined"
  logger(
    ['porg', 'unhandledRejection', 'emerg'],
    `${error.message} - ${error.stack}`
  )
})

let config = null
let lockProvider = null

const setConfig = ({ basePath, redefine }) => {
  let papagaio = {}
  try {
    if (!redefine && config !== null) {
      throw new Error('Config already set')
    } else {
      config = null
    }
    // Get all Configuration paths
    let configurationPaths = [path.join(basePath, 'porg.yml')]
    // if (opts.configurationFile) {
    //   configurationPaths = [path.join(basePath, opts.configurationFile)]
    // } else if (opts.configurationFiles) {
    //   configurationPaths = opts.configurationFiles.map((el) => {
    //     return path.join(basePath, el)
    //   })
    // }
    // Merge all Configurations
    for (let item in configurationPaths) {
      if (!fs.existsSync(configurationPaths[item])) {
        throw new Error(
          `Missing configuration file at ${configurationPaths[item]}`
        )
      }
      try {
        config = {
          ...config,
          ...camelcaseKeys(
            yaml.safeLoad(fs.readFileSync(configurationPaths[item], 'utf8')),
            { deep: true }
          )
        }
      } catch (err) {
        throw new Error('Error processing porg.yml: ' + err.message)
      }
    }

    const validation = Joi.validate(config, configSchema, {
      allowUnknown: true
    })
    if (validation.error) {
      throw new Error(
        'Error processing options of porg.yml: ' + validation.error
      )
    }
    config = validation.value
    resetMapErrors()
    papagaio = config.papagaio
  } catch (err) {
    throw err
  } finally {
    configLogger(papagaio)
  }
}

const porgFork = async ({ porgYmlPath }) => {
  setConfig({ basePath: porgYmlPath })
  const setupApplicationErrorsScriptPath = path.join(porgYmlPath, 'errors', 'index.js')
  if (fs.existsSync(setupApplicationErrorsScriptPath)) {
    const setupPorgErrors = require('./plugins/errors/internal-errors')
    const setupApplicationErrors = require(setupApplicationErrorsScriptPath)
    setupPorgErrors()
    setupApplicationErrors()
  }

  if (config.drivers) {
    for (let [driver, options] of Object.entries(config.drivers)) {
      runConfigWithDriver({ driver, options })
    }
  }
  if (config.lockProvider) {
    lockProvider = getLockProvider({ name: config.lockProvider.type })
  }

  if (config.email) {
    await emailSetup({
      emailConfig: config.email,
      nodeStartPath: porgYmlPath
    })
  }

  if (config.storage) {
    storageSetup({ storageConfig: config.storage })
  }
}

const porg = async opts => {
  let configTasks
  if (config === null) {
    setConfig({ basePath: path.dirname(require.main.filename) })
  }

  opts = opts || {}
  if (!opts.runOnce) {
    opts.runOnce = async () => {}
  }
  if (!opts.afterTasksStart) {
    opts.afterTasksStart = async () => {}
  }

  if (config.drivers) {
    for (let [driver, options] of Object.entries(config.drivers)) {
      runConfigWithDriver({ driver, options })
    }
  }

  if (config.lockProvider) {
    lockProvider = getLockProvider({ name: config.lockProvider.type })
  }

  if (config.email) {
    await emailSetup({
      emailConfig: config.email,
      nodeStartPath: config.nodeStartPath
    })
  }

  if (config.storage) {
    storageSetup({ storageConfig: config.storage })
  }
  if (config.tasks) {
    configTasks = await configTaskRunner({
      lockProviderName: config.lockProvider.type,
      persistentTaskProviderName: config.tasks.persistenceProvider,
      applicationName: config.application.name,
      nodeStartPath: config.nodeStartPath
    })
  }

  if (cluster.isMaster) {
    await opts.runOnce()
    await opts.afterTasksStart()
  }

  if (
    cluster.isMaster &&
    (process.env.NODE_ENV === 'production' ||
      config.application.forkInDevelopment)
  ) {
    if (process.env.NODE_ENV === 'development') {
      cluster.setupMaster({
        execArgv: ['-r', 'babel-register']
      })
    }
    const numCPUs = os.cpus().length
    for (let i = 0; i < numCPUs; i++) {
      cluster.fork()
    }
  } else {
    try {
      logger(['info', 'server', 'boot'], `${config.application.name} started.`)
      logger(
        ['info', 'bootstrap', 'server'],
        `${config.application.name} API (Process: ${
          process.pid
        }) is now running on port ${config.application.backendPort}`
      )
      const server = await serverFactory({ config })
      logger(['info', 'bootstrap', 'server'], `End server creation`)
      if (config.tasks) {
        await setupTasksEndpoints({
          server,
          config: config.tasks
        })
      }

      if (config.fileUploadHandlers) {
        await setupFileUploadHandlers({
          server,
          fileUploadHandlers: config.fileUploadHandlers
        })
      }
      return {
        getHapiServer: () => {
          return server
        },
        start: async () => {
          try {
            if (config.migrations) {
              logger(['info', 'server', 'boot'], `Running any needed migrations`)
              if (!config.lockProvider) {
                throw new Error('A lock provider must be defined to run migrations')
              }
              await runMigrations({
                lockProviderName: config.lockProvider.type,
                migrationPersistenceProviderName: config.migrations.persistenceProvider,
                applicationName: config.application.name,
                nodeStartPath: config.nodeStartPath
              })
            }
            if (config.tasks) {
              await configTasks.start()
            }
            await server.start()
          } catch (error) {
            logger(['err', 'porg', 'bootstrap'], `${error.message} - ${error.stack}`)
          }
          if (config.websockets && config.websockets.enabled) {
            try {
              logger(
                ['info', 'porg', 'socket'],
                'SocketIO enabled starting setup...'
              )
              await setSocketIO({ config, listener: server.listener })
              logger(['info', 'porg', 'socket'], 'SocketIO started')
            } catch (err) {
              logger(['err', 'bootstrap'], 'Error starting application')
            }
          }
          return server
        }
      }
    } catch (error) {
      logger(['err', 'porg', 'bootstrap'], `${error.message} - ${error.stack}`)
      process.exit(1)
    }
  }
}

const cleanDbs = async ({ config }) => {
  const validation = Joi.validate(config, configSchema, { allowUnknown: true })
  if (validation.error) {
    throw new Error(validation.error)
  }
  config = validation.value
  try {
    for (let [driver, options] of Object.entries(config.drivers)) {
      const driverObject = runConfigWithDriver({ driver, options })
      logger(
        ['info', 'testing', 'migration'],
        `Cleanning database with driver ${driver} for tests`
      )
      await driverObject.cleanDatabase()
    }
  } catch (err) {
    logger(['error', 'testing', 'migration'], err.message)
  }
}

const closeDbs = async ({ config }) => {
  const validation = Joi.validate(config, configSchema, { allowUnknown: true })
  if (validation.error) {
    throw new Error(validation.error)
  }
  config = validation.value
  try {
    for (let [driver, options] of Object.entries(config.drivers)) {
      const driverObject = runConfigWithDriver({ driver, options })
      logger(
        ['info', 'testing', 'migration'],
        `Close database with driver ${driver} for tests`
      )
      await driverObject.shutdown()
    }
  } catch (err) {
    logger(['error', 'testing', 'migration'], err.message)
  }
}

const TestUtils = {
  cleanDbs,
  closeDbs,
  path: relativePath => {
    const rootPath = process.env.PWD
    if (relativePath.startsWith('@')) {
      return path.join(rootPath, relativePath.replace('@', ''))
    } else if (relativePath.startsWith('#')) {
      return path.join(rootPath, 'test', relativePath.replace('#', ''))
    } else {
      return relativePath
    }
  }
}

export {
  config,
  porg,
  consoleFormat,
  Mongo,
  Smtp,
  Email,
  Storage,
  Task,
  mapper,
  logger,
  setupError,
  errorWithKey,
  loadMigrationFile,
  loadMigrationFileStream,
  clientProm,
  StatusCodes,
  TestUtils,
  setConfig,
  Elasticsearch,
  getSocketIO,
  lockProvider,
  tasks,
  porgFork
}
