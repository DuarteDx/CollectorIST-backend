import * as path from 'path'
import * as fs from 'fs'
import * as os from 'os'
import mkdirp from 'mkdirp'
import { errorWithKey } from '@/plugins/errors'
import UploadSessionState from '@/file-upload-handlers/constants/UploadSessionState'
import CryptoJS from 'crypto-js'
import fileType from 'file-type'
import FilePath from '@/file-upload-handlers/util/FilePath'

const writeFileToDisk = ({ file, filePath, extension, mimeTypes }) => {
  mkdirp.sync(path.dirname(filePath))
  return new Promise((resolve, reject) => {
    const filePersistence = fs.createWriteStream(filePath)
    filePersistence.on('error', (err) => { reject(err) })

    let hash = CryptoJS.algo.SHA256.create()
    let dataLength = 0
    let isValidFile = false
    file.pipe(filePersistence)
    file
      .on('data', (chunk) => {
        if (!isValidFile) {
          const ft = fileType(chunk)
          if (ft && mimeTypes) {
            // reject file if mime or extension mismatch
            if (!mimeTypes.includes(ft.mime) || ft.ext !== extension.slice(1)) {
              file.emit('error', errorWithKey('invalid-file', { }))
            } else {
              isValidFile = true
            }
          }
        }
        dataLength += chunk.length
        hash.update(CryptoJS.lib.WordArray.create(chunk))
      })
      .on('end', async () => {
        return resolve({ checksum: hash.finalize().toString(), fileSize: dataLength })
      })
      .on('error', (error) => {
        deleteFile({ filePath })
        return reject(error)
      })
  })
}

function deleteFile ({ filePath }) {
  if (fs.existsSync(filePath)) {
    fs.unlinkSync(filePath)
  }
}

const getChecksumFromChunk = ({ filePath, start, end }) => {
  const readStream = fs.createReadStream(filePath, { start, end })
  return new Promise((resolve, reject) => {
    let hash = CryptoJS.algo.SHA256.create()
    readStream
      .on('data', function (chunk) {
        hash.update(CryptoJS.lib.WordArray.create(chunk))
      })
      .on('end', function () {
        return resolve(hash.finalize().toString())
      })
      .on('error', (error) => {
        return reject(error)
      })
  })
}

const generateChallenges = async ({ filePath, fileSize }) => {
  const totalChallenges = Math.ceil(Math.min(30, fileSize * 0.001))
  let indexes = []
  let lastRandom = -1
  let newRandom
  while (indexes.length < totalChallenges * 2) {
    newRandom = Math.floor(Math.random() * fileSize)
    if (newRandom !== lastRandom) {
      indexes.push(newRandom)
    }
  }
  let challenges = []
  for (let i = 0; i < indexes.length; i++) {
    if (i % 2 === 0) {
      const range = indexes.slice(i, i + 2).sort((e1, e2) => e1 - e2)
      let challenge = { start: range[0], end: range[1] }
      const chunkChecksum = await getChecksumFromChunk({ filePath, ...challenge })
      challenge.checksum = chunkChecksum
      challenges.push(challenge)
    }
  }
  return challenges
}

export default async ({ persistenceProvider, StorageProvider, tempStorageRootPath, mimeTypes, deduplication, session, file }) => {
  // Fail fast verification
  if (!file || (mimeTypes && !mimeTypes.includes(file.hapi.headers['content-type']))) {
    throw errorWithKey('invalid-file', {})
  }

  let uploadSession = await persistenceProvider.getUploadSession({ id: session })

  if (!uploadSession || uploadSession.state !== UploadSessionState.WAITING_FOR_FILE) {
    throw errorWithKey('upload-session-not-found', {
      ctx: { id: session }
    })
  }
  const extension = path.extname(file.hapi.filename)
  const filename = session + extension

  const newFile = {
    _id: session,
    originalFilename: file.hapi.filename,
    filename
  }
  const tempFilePath = path.join(tempStorageRootPath || os.tmpdir(), filename)
  try {
    const { checksum, fileSize } = await writeFileToDisk({ file, filePath: tempFilePath, extension, mimeTypes })
    newFile.checksum = checksum
    newFile.size = fileSize
    if (deduplication) {
      newFile.challenges = await generateChallenges({ filePath: tempFilePath, fileSize: newFile.size })
    }
    const folderTree = FilePath.getExpandedPathTree({ value: session, folderNameSize: 3 })
    const relativeFilePath = path.join(...folderTree, filename)
    await StorageProvider.storeFile({ file: fs.createReadStream(tempFilePath), filePath: relativeFilePath })
  } catch (err) {
    throw errorWithKey('internal-error', {tags: ['emerg', 'porg'], cause: JSON.stringify(err)})
  }

  await persistenceProvider.insertFile({ file: newFile })
  await persistenceProvider.setUploadSessionState({ id: session, state: UploadSessionState.FILE_RECEIVED })
  return { id: newFile._id }
}
