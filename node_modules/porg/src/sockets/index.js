import path from 'path'
import fs from 'fs'
import _ from 'underscore'
import { logger } from 'papagaio'
import SocketIO from 'socket.io'
import { validateUserSessionCookies } from '@/plugins/auth'
import Joi from 'joi'
import { errorWithKey } from '@/plugins/errors'

const SOCKETS_FOLDER = 'sockets/on'
let socketIO

const setSocketIO = async ({config, listener}) => {
  // Configuration schema
  const socketConfigsSchema = {
    config: {
      description: Joi.string(),
      event: Joi.string().required(),
      auth: Joi.object().keys({
        'user-session': Joi.array().items(Joi.string()),
        bearers: Joi.array().items(Joi.string().valid(Object.keys(config.auth.staticBearer)))
      })
    },
    handler: Joi.func()
  }

  // Read socket configurarion files
  let dirMainFile = path.dirname(require.main.filename)
  if (config.nodeStartPath) {
    dirMainFile = path.resolve(dirMainFile, config.nodeStartPath)
  }
  let normalizePath = path.join(dirMainFile, SOCKETS_FOLDER)
  const socketsConfigs = []
  if (!fs.existsSync(normalizePath)) {
    logger(['info', 'porg', 'sockets'], 'Porg could not find any sockets folder')
  }
  fs.readdirSync(normalizePath).forEach((file) => {
    const module = require(path.join(normalizePath, file))
    if (module.handler && module.config) {
      socketsConfigs.push(module)
    } else {
      logger(['info', 'porg', 'sockets'], 'Porg could not find any sockets folder')
    }
  })

  // Validate socket configuration files
  if (socketsConfigs.length <= 0) {
    logger(['info', 'porg', 'sockets'], 'Porg could not find any socket handler files in sockets folder')
    return
  }
  logger(['info', 'porg', 'socket-io'], `Porg found ${socketsConfigs.length} on event handlers`)
  await socketsConfigs.forEach((socketConfig) => {
    const validation = Joi.validate(socketConfig, socketConfigsSchema)
    if (validation.error) {
      throw errorWithKey('validation-error', {tags: ['emerg', 'porg', 'socket-io'], cause: `Error validating socket configuration \n ${validation.error}`})
    }
  })

  // Start socket server
  socketIO = SocketIO(listener)

  // Setup on connection event
  socketIO.on('connection', async function (socket) {
    logger(['info', 'porg', 'socket-io'], 'Client starting connection...')
    try {
      const auth = await authenticateSocketConnection(config, socket)
      socketsConfigs.forEach((socketConfig) => {
        // If user is in a session and the event supports user-session
        if (auth.type === 'principal' && Object.keys(socketConfig.config.auth).includes('user-session')) {
          const principal = auth.principal
          const missingRoles = _.difference(socketConfig.config.auth['user-session'], principal.roles)
          if (missingRoles.length <= 0) {
            socket.on(socketConfig.config.event, function (params) {
              return socketConfig.handler({ socket, auth, params })
            })
            logger(['info', 'porg', 'socket-io'], `Socket IO handler configured for event ${socketConfig.config.event} with roles ${socketConfig.config.auth['user-session']}`)
            return
          }
          logger(['warn', 'porg', 'socket-io'], `Client with username ${principal.sub} tried to send an event ${socketConfig.config.event} with roles ${principal.roles}`)
        } else if (auth.type === 'bearer' && socketConfig.config.auth.bearers) {
          const bearers = socketConfig.config.auth.bearers
          const token = auth.token
          bearers.forEach((bearer) => {
            if (token === config.auth.staticBearer[bearer]) {
              socket.on(socketConfig.config.event, function (params) {
                return socketConfig.handler({ socket, auth, params })
              })
              logger(['info', 'porg', 'socket-io'], `Socket IO handler configured for event ${socketConfig.config.event} with bearer ${token}`)
            }
          })
        }
      })
      logger(['info', 'porg', 'socket-io'], `Connection established`)
    } catch (err) {
      logger(['info', 'porg', 'socket-io'], `Unknown user tried to connect to Socket IO\n${err}`)
      socket.disconnect()
    }
  })
}

async function authenticateSocketConnection (config, socket) {
  // Verify user session
  let cookies = socket.handshake.headers.cookie
  if (cookies) {
    cookies = cookies.split('; ')
    if (cookies.length > 1) {
      const pSessionCookies = cookies.filter((cookie) => {
        return cookie.startsWith('P_SESSION')
      })
      const jwtToken = pSessionCookies[0].split('=')[1]
      const principal = await validateUserSessionCookies({ jwtToken })
      if (principal && principal.credentials) {
        return {
          type: 'principal',
          principal: principal.credentials
        }
      }
    }
  }

  // Verify bearer token
  const token = socket.handshake.query.token
  if (token) {
    return {
      type: 'bearer',
      token
    }
  }
  throw errorWithKey('not-authorized', {tags: ['warn', 'porg', 'socket-io'], cause: `Error validating socket configuration`})
}

const getSocketIO = () => {
  return socketIO
}

export default {
  getSocketIO,
  setSocketIO
}
