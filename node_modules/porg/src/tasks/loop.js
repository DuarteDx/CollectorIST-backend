// import { logger } from 'papagaio'
import { fork } from 'child_process'
import cronParser from 'cron-parser'
import path from 'path'
import sha1 from 'sha1'
import moment from 'moment'
// import { transform } from 'babel-core'
// import requireString from 'require-from-string'
import StatusTask from '@/tasks/StatusTask'
// Time to check for new tasks to run, and to process cron expressions
const CHECK_TASK_INTERVAL = 1000 // Time miliseconds
// Number of tasks instance that should be created in advance for a cron expression
const NUMBER_OF_JOBS_FOR_TASK = 3
// Max durantion of time between taskinstance.date and now, from where task shoud be ignored and not runned
const POINT_OF_NO_RETURN = 30 // In minutes
// Map of workers
const mapOfWorkers = new Map()

// const getClassTask = async ({persistentTaskProvider, tasksMap, name}) => {
//   let classObject = tasksMap.get(name)
//   if (classObject) {
//     return classObject
//   } else {
//     const task = await persistentTaskProvider.getTask({taskName: name})
//     const directory = path.join(__dirname, '../../.babelrc')
//     const { code } = transform(task.src, {extends: directory})
//     classObject = requireString(code)
//     const TaskClass = classObject.default
//     return new TaskClass({name})
//   }
// }

const killTask = async (taskInstanceId) => {
  const infoWorker = mapOfWorkers.get(taskInstanceId)
  infoWorker.worker.kill('SIGKILL')
  await infoWorker.session.releaseLock({lockId: infoWorker.lockId})
  await infoWorker.session.destroySession()
  clearInterval(infoWorker.sessionRenewInterval)
}

const processClose = async ({m, persistentTaskProvider, taskInstance}) => {
  await killTask(taskInstance.id)
  await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Completed, endDate: moment().valueOf()})
}

const processUpdate = async ({m, worker, persistentTaskProvider}) => {
  await persistentTaskProvider.updateTaskInstance(m.params)
}

const processAbort = async ({m, persistentTaskProvider, taskInstance}) => {
  await killTask(taskInstance.id)
  await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Aborted, message: m.err, endDate: moment().valueOf()})
}

export default ({ persistentTaskProvider, lockProvider, tasksMap }) => {
  setInterval(async () => {
    let sessionRenewInterval

    // START - FIND TASKS AWAITING TO RUN AND RUN THEM
    const tasksInstances = await persistentTaskProvider.getTasksInstances({status: StatusTask.Pending})
    const now = moment()
    for (let taskInstance of tasksInstances) {
      let taskDate = moment(taskInstance.date)
      if (now.diff(taskDate) > 0) {
        let duration = moment.duration(now.diff(taskDate))
        const sessionRunTask = await lockProvider.createSession()
        try {
          if (!(await sessionRunTask.attemptLock({lockId: `${taskInstance.name}-${taskInstance.id}`}))) {
            await sessionRunTask.destroySession()
            continue
          }
          sessionRenewInterval = setInterval(async () => {
            await sessionRunTask.renewSession()
          }, 5000)
          const taskInLock = await persistentTaskProvider.getTaskInstanceById({id: taskInstance.id})
          if (taskInLock.status === StatusTask.Pending) {
            if (duration.asMinutes() > POINT_OF_NO_RETURN) {
              await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Aborted, message: `Point of no return: ${duration.asMinutes()} limit ${POINT_OF_NO_RETURN}`})
            } else {
              const taskPath = tasksMap.get(taskInstance.name)
              const taskInfo = await persistentTaskProvider.getTask({taskName: taskInstance.name})
              const worker = fork(path.join(__dirname, '/fork.js'), [`${taskInstance.name}-${taskInstance.id}`], {
                execArgv: ['-r', 'babel-register']
              })
              mapOfWorkers.set(taskInstance.id, {worker, session: sessionRunTask, lockId: `${taskInstance.name}-${taskInstance.id}`, sessionRenewInterval})
              worker.on('message', async (m) => {
                switch (m.type) {
                  case 'close': await processClose({m, persistentTaskProvider, taskInstance})
                    break
                  case 'update': await processUpdate({m, persistentTaskProvider})
                    break
                  case 'abort': await processAbort({m, persistentTaskProvider, taskInstance})
                    break
                  default: throw new Error('invalid type')
                }
              })
              const sessionId = sessionRunTask.getSessionId()
              worker.send({ type: 'init', instanceId: taskInstance.id, porgYmlPath: path.dirname(require.main.filename), taskPath, taskInfo, input: taskInstance.input, sessionId })
            }
          }
        } catch (err) {
          clearInterval(sessionRenewInterval)
          sessionRunTask.destroySession()
          throw err
        }
      }
    }
    // END - FIND TASKS AWAITING TO RUN AND RUN THEM

    // START - FIND TASKS WITH A CRON AND CREATE INSTANCES TASKS
    const sessionFindNewTasks = await lockProvider.createSession()
    try {
      sessionRenewInterval = setInterval(() => {
        sessionFindNewTasks.renewSession()
      }, 5000)
      if (!(await sessionFindNewTasks.attemptLock({lockId: 'tasks-list'}))) {
        clearInterval(sessionRenewInterval)
        sessionFindNewTasks.destroySession()
        return
      }
      const tasks = await persistentTaskProvider.getTasks()
      for (let task of tasks) {
        if (task.execution === 'cron') {
          const tasksInstances = await persistentTaskProvider.getTaskInstances({name: task.id, status: StatusTask.Pending})
          if (tasksInstances.length < NUMBER_OF_JOBS_FOR_TASK) {
            const currentTime = tasksInstances.length === 0 ? moment().valueOf() : moment(tasksInstances[tasksInstances.length - 1].date).valueOf()
            const numberOfNewInstancesForTask = NUMBER_OF_JOBS_FOR_TASK - tasksInstances.length
            const interval = cronParser.parseExpression(task.cron, {currentDate: currentTime})
            for (let n = 0; n < numberOfNewInstancesForTask; ++n) {
              let taskTime = moment(interval.next().getTime())
              await persistentTaskProvider.createTaskInstance({id: sha1(String(task.id + taskTime)), name: task.id, date: taskTime.toDate(), executionTimeLimit: task.executionTimeLimit, input: JSON.parse(task.defaultInput)})
            }
          }
        }
      }
      sessionFindNewTasks.releaseLock({lockId: 'tasks-list'})
      sessionFindNewTasks.destroySession()
      clearInterval(sessionRenewInterval)
    } catch (err) {
      clearInterval(sessionRenewInterval)
      sessionFindNewTasks.destroySession()
      throw err
    }
    // END - FIND TASKS WITH A CRON AND CREATE INSTANCES TASKS

    // START - FIND TASKS RUNNING AND KILL THEM IF TIME LIMIT EXCEDED
    const sessionTimeLimitTasks = await lockProvider.createSession()
    try {
      sessionRenewInterval = setInterval(() => {
        sessionTimeLimitTasks.renewSession()
      }, 5000)
      if (!(await sessionTimeLimitTasks.attemptLock({lockId: 'tasks-time-limit'}))) {
        clearInterval(sessionRenewInterval)
        sessionTimeLimitTasks.destroySession()
        return
      }

      const tasksInstances = await persistentTaskProvider.getTasksInstances({status: StatusTask.Running})
      const now = moment()
      for (let taskInstance of tasksInstances) {
        const startDate = moment(taskInstance.startDate)
        const durantionTask = moment.duration(now.diff(startDate))
        if (durantionTask.asMinutes() > taskInstance.executionTimeLimit) {
          const worker = mapOfWorkers.get(taskInstance.id)
          if (worker) {
            await killTask(taskInstance.id)
            await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Aborted, message: 'Time limit Exceded', endDate: moment().valueOf()})
            continue
          }
        }
        if (durantionTask.asMinutes() > (taskInstance.executionTimeLimit + 60)) {
          await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Aborted, message: 'Time limit Exceded (no worker killed)', endDate: moment().valueOf()})
          continue
        }

        if (taskInstance.killswitch) {
          const worker = mapOfWorkers.get(taskInstance.id)
          if (worker) {
            await killTask(taskInstance.id)
            await persistentTaskProvider.updateTaskInstance({id: taskInstance.id, status: StatusTask.Aborted, message: 'Killed by administrator', endDate: moment().valueOf()})
          }
        }
      }

      sessionTimeLimitTasks.releaseLock({lockId: 'tasks-time-limit'})
      sessionTimeLimitTasks.destroySession()
      clearInterval(sessionRenewInterval)
    } catch (err) {
      clearInterval(sessionRenewInterval)
      sessionTimeLimitTasks.destroySession()
      throw err
    }
    // END -  FIND TASKS RUNNING AND KILL THEM IF TIME LIMIT EXCEDED
  }, CHECK_TASK_INTERVAL)
}
