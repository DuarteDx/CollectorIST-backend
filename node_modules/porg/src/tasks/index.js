import { logger } from 'papagaio'
import path from 'path'
import fs from 'fs'
import Task from '@/tasks/Task'
import { getLockProvider, getPersistenceTaskProvider } from '@/providers'
import { sleep } from '@/utils/index'
import cronParser from 'cron-parser'
import sha1 from 'sha1'
import moment from 'moment'
import loop from '@/tasks/loop'
import GetDefinedTasks from '@/tasks/controllers/GetDefinedTasks'
import GetInstanceTasks from '@/tasks/controllers/GetInstanceTasks'
import GetInstanceTaskById from '@/tasks/controllers/GetInstanceTaskById'
import CreateInstanceTask from '@/tasks/controllers/CreateInstanceTask'
import CreateDefinedTask from '@/tasks/controllers/CreateDefinedTask'
import UpdateInstanceTask from '@/tasks/controllers/UpdateInstanceTask'

const TASKS_FOLDER = 'tasks'
// Default max number of minutes a task will run
const EXECUTION_TIME_LIMIT = 2 // In minutes

export const tasks = {
  runTask: async ({ name, input }) => {
    throw new Error('Tasks not defined in porg')
  },
  killTask: async ({ id }) => {
    throw new Error('Tasks not defined in porg')
  }
}

export const configTaskRunner = async ({lockProviderName, persistentTaskProviderName, applicationName, nodeStartPath}) => {
  logger(['info', 'tasks'], `Starting tasks config with ${persistentTaskProviderName}`)
  let dirMainFile = path.dirname(require.main.filename)
  if (nodeStartPath) {
    dirMainFile = path.resolve(dirMainFile, nodeStartPath)
  }
  let normalizePath = path.join(dirMainFile, TASKS_FOLDER)
  let lockProvider = getLockProvider({name: lockProviderName})
  let persistentTaskProvider = getPersistenceTaskProvider({name: persistentTaskProviderName})

  const sessionLoadTasks = await lockProvider.createSession()
  const sessionRenewInterval = setInterval(async () => {
    await sessionLoadTasks.renewSession()
  }, 5000)
  while (!(await sessionLoadTasks.attemptLock({lockId: 'tasks'}))) {
    await sleep(1000)
  }

  let tasksMap = new Map()
  const loadtasksPaths = [path.resolve(__dirname, './internal')]
  if (fs.existsSync(normalizePath)) {
    loadtasksPaths.push(normalizePath)
  } else {
    logger(['info', 'porg', 'tasks'], 'Porg could not find any tasks folder.')
  }

  try {
    for (let loadPath of loadtasksPaths) {
      for (let file of fs.readdirSync(loadPath)) {
        const filePath = path.join(loadPath, file)
        let loadedTask = require(filePath)
        let taskExecution = loadedTask.cron ? 'cron' : 'none'
        let TaskClass = loadedTask.default
        let taskCronExpression = loadedTask.cron
        let executionTimeLimit = loadedTask.timeLimitInMinutes ? loadedTask.timeLimitInMinutes : EXECUTION_TIME_LIMIT
        let defaultInput
        try {
          defaultInput = loadedTask.defaultInput ? JSON.stringify(loadedTask.defaultInput) : JSON.stringify({})
        } catch (err) {
          logger(['info', 'tasks'], `Error in default input ${file} converting to "{}"`)
          defaultInput = JSON.stringify({})
        }
        let execution
        if (taskExecution === 'cron') {
          cronParser.parseExpression(taskCronExpression) // throws error if not a cron expression
          execution = 'cron'
        } else if (taskExecution === 'none') {
          execution = 'none'
        } else {
          throw new Error('Invalid execution option')
        }
        const src = fs.readFileSync(path.join(loadPath, file), 'utf8')
        let taskName = file.replace(/.js$/, '')
        let version = sha1(String(taskName + src))
        if (Task.isPrototypeOf(TaskClass)) {
          logger(['info', 'tasks'], `Loading task ${taskName}`)
          // let task = new TaskClass({name: taskName, persistentTaskProvider})
          await persistentTaskProvider.addTask({taskName, execution, cron: taskCronExpression, version, executionTimeLimit, defaultInput})
          tasksMap.set(taskName, filePath)
        }
      }
    }
    await sessionLoadTasks.releaseLock({lockId: 'tasks'})
  } catch (err) {
    throw err
  } finally {
    clearInterval(sessionRenewInterval)
    sessionLoadTasks.destroySession()
    logger(['info', 'tasks'], `Ending tasks config with ${persistentTaskProviderName}`)
  }

  tasks.runTask = async ({ name, input }) => {
    const now = moment()
    const task = await persistentTaskProvider.getTask({taskName: name})
    const id = sha1(String(task.id + now))
    try {
      if (input) {
        if (typeof input !== 'object') {
          throw new Error()
        }
        JSON.stringify(input) // Test if it is possible to stringify, to see if valid json
      } else {
        input = JSON.parse(task.defaultInput)
      }
    } catch (err) {
      input = {}
    }
    await persistentTaskProvider.createTaskInstance({id, name: task.id, date: now.valueOf(), executionTimeLimit: task.executionTimeLimit, input})
    return {
      getId () {
        return id
      },
      async kill () {
        await persistentTaskProvider.updateTaskInstance({id: this.getId(), killswitch: true})
      },
      async updateExecutionTimeLimit (minutes) {
        if (!(Number.isInteger(minutes) && minutes > 0)) {
          throw new Error('Minutes must be a integer greater than 0')
        }
        await persistentTaskProvider.updateTaskInstance({id: this.getId(), executionTimeLimit: minutes})
      },
      async getInfo () {
        return persistentTaskProvider.getTaskInstanceById({id: this.getId()})
      }
    }
  }
  tasks.killTask = async ({ id }) => {
    await persistentTaskProvider.updateTaskInstance({id, killswitch: true})
  }
  return {
    start: async () => {
      loop({ persistentTaskProvider, lockProvider, tasksMap })
    }
  }
}

export const setupTasksEndpoints = async ({server, config}) => {
  let persistentTaskProvider = getPersistenceTaskProvider({name: config.persistenceProvider})

  server.route({
    path: '/api/v1/tasks',
    method: 'GET',
    handler: GetDefinedTasks.handler({persistentTaskProvider}),
    config: GetDefinedTasks.config(config)
  })

  server.route({
    path: '/api/v1/tasks',
    method: 'POST',
    handler: CreateDefinedTask.handler({persistentTaskProvider}),
    config: CreateDefinedTask.config(config)
  })

  server.route({
    path: '/api/v1/tasks/{id}/instances',
    method: 'POST',
    handler: CreateInstanceTask.handler({persistentTaskProvider}),
    config: CreateInstanceTask.config(config)
  })

  server.route({
    path: '/api/v1/tasks/{id}/instances',
    method: 'PUT',
    handler: UpdateInstanceTask.handler({persistentTaskProvider}),
    config: UpdateInstanceTask.config(config)
  })

  server.route({
    path: '/api/v1/tasks-instances',
    method: 'GET',
    handler: GetInstanceTasks.handler({persistentTaskProvider}),
    config: GetInstanceTasks.config(config)
  })

  server.route({
    path: '/api/v1/tasks-instances/{id}',
    method: 'GET',
    handler: GetInstanceTaskById.handler({persistentTaskProvider}),
    config: GetInstanceTaskById.config(config)
  })
}
