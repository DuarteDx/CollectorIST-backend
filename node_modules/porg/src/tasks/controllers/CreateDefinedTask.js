import Joi from 'joi'
import path from 'path'
import { transform } from 'babel-core'
import requireString from 'require-from-string'
import cronParser from 'cron-parser'
import sha1 from 'sha1'
import { Task } from '@/tasks'

const EXECUTION_TIME_LIMIT = 1 // In minutes

const handler = ({persistentTaskProvider}) => {
  return async (request, h) => {
    try {
      const src = request.payload.src
      const directory = path.join(__dirname, '../../../.babelrc')
      const { code } = transform(src, {extends: directory})
      const loadedTask = requireString(code)
      let taskExecution = loadedTask.execution
      let TaskClass = loadedTask.default
      let taskCronExpression = loadedTask.cron
      let executionTimeLimit = loadedTask.timeLimit ? loadedTask.timeLimit : EXECUTION_TIME_LIMIT
      let execution
      if (taskExecution === 'cron') {
        cronParser.parseExpression(taskCronExpression) // throws error if not a cron expression
        execution = 'cron'
      } else if (taskExecution === 'none') {
        execution = 'none'
      } else {
        throw new Error('Invalid execution option')
      }
      let taskName = TaskClass.name
      let version = sha1(String(taskName + src))
      if (Task.isPrototypeOf(TaskClass)) {
        // let task = new TaskClass(taskName)
        await persistentTaskProvider.addTaskSource({taskName, execution, cron: taskCronExpression, version, executionTimeLimit, src})
      }
      return 'ok'
    } catch (err) {
      return err.message
    }
  }
}

const config = ({roles, twoFactor}) => {
  return {
    description: 'Create task defined',
    validate: {
      payload: {
        src: Joi.string().required()
      }
    },
    plugins: {
      'porg-auth': {
        type: 'user-session',
        twoFactor,
        roles
      }
    }
  }
}

export default { handler, config }
