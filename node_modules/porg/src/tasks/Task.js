import { lockProvider } from '@/'

const mapLocks = (lockMap) => {
  const locks = {}
  for (const [key, value] of lockMap.entries()) {
    locks[key] = value
  }
  return locks
}
export default class Task {
  constructor ({name}) {
    this.name = name
    this.running = false
  }

  async run () {
    throw new Error('You need to extend Task class')
  }

  async execute ({ id, input, sessionId }) {
    try {
      this.id = id
      this.text = ''
      this.running = true
      this.lockMap = new Map()
      this.session = await lockProvider.getSession({ id: sessionId })
      await this.progress(0)
      await this.run(input)
      await this.progress(100)
      await this.flushPrint()
      this.running = false
      const nOpenLocks = Array.from(this.lockMap.values()).filter(a => a).length
      if (nOpenLocks > 0) {
        await this.releaseAllLocks()
        process.send({type: 'abort', err: 'Task ended with open locks'})
      } else {
        process.send({type: 'close'})
      }
    } catch (err) {
      await this.releaseAllLocks()
      if (err.key) {
        const tags = err.getTags()
        let message = '[ '
        for (let n = 0; n < tags.length; ++n) {
          message += tags[n]
          message += (tags.length - 1) === n ? ' ]' : ', '
        }
        message += ' ' + (err.getCause() ? err.getCause() : err.key)
        this.println(message)
        const metadata = err.getMetadata()
        for (const key in metadata) {
          this.println(`    ${key}:${metadata[key]}`)
        }
        this.println(err.stack)
        await this.flushPrint()
        process.send({type: 'abort', err: 'Application error with key: ' + err.key})
      } else {
        this.println(err.stack)
        await this.flushPrint()
        process.send({type: 'abort', err: err.message})
      }
    }
  }

  async progress (percentage) {
    if (!this.running) {
      throw new Error('This method can only be called when task is running')
    }
    process.send({type: 'update', params: {id: this.id, percentage}})
  }

  println (text) {
    this.print(text + '\n')
  }

  print (text) {
    if (!this.running) {
      throw new Error('This method can only be called when task is running')
    }
    this.text += text
  }

  clear () {
    this.text = ''
  }

  async lock (tag) {
    if (this.lockMap.has(tag) && this.lockMap.get(tag)) {
      throw new Error(`Can't lock tag ${tag} because task ${this.id} already has the lock`)
    } else {
      if (await this.session.attemptLock({lockId: `porg-tag-${tag}`})) {
        this.lockMap.set(tag, true)
        process.send({type: 'update', params: {id: this.id, locks: mapLocks(this.lockMap)}})
        return true
      } else {
        return false
      }
    }
  }

  hasLock (tag) {
    return this.lockMap.has(tag)
  }

  async unlock (tag) {
    if (this.lockMap.has(tag)) {
      await this.session.releaseLock({lockId: `porg-tag-${tag}`})
      this.lockMap.set(tag, false)
      process.send({type: 'update', params: {id: this.id, locks: mapLocks(this.lockMap)}})
      return true
    } else {
      throw new Error(`Can't unlock tag ${tag} because task ${this.id} doesn't has lock`)
    }
  }

  async releaseAllLocks () {
    for (const [lockTag, lockOpen] of this.lockMap.entries()) {
      if (lockOpen) {
        await this.unlock(lockTag)
      }
    }
  }

  async flushPrint () {
    if (!this.running) {
      throw new Error('This method can only be called when task is running')
    }
    process.send({type: 'update', params: {id: this.id, text: this.text}})
  }
}
