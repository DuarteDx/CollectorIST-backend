import { errorWithKey } from '@/plugins/errors'
import { logger } from 'papagaio'
import { getJwt } from '@/plugins/auth/services/JwtUtils'

const handler = ({ samlOptions, options }) => {
  return async (request, h) => {
    return new Promise((resolve, reject) => {
      samlOptions.sp.post_assert(samlOptions.idp, { request_body: request.payload }, async (err, response) => {
        if (err) {
          return reject(err)
        }
        try {
          let credentials = await options.jwt.getPayloadForUsername(response.user.attributes)
          if (credentials === null) {
            return resolve(h.redirect(options.saml.localAppUrl + options.unauthorizedPath))
          }
          credentials.nId = response.user.name_id
          credentials.sIndex = response.user.session_index
          const token = getJwt({
            payload: credentials,
            secretOrPrivateKey: options.jwt.secret,
            options: { expiresIn: options.sessionTime || 60 }
          })
          let callbackUrl = request.payload['RelayState']
          let cbUrl = new URL(callbackUrl)
          let serviceUrl = new URL(samlOptions.serviceUrl)
          if (cbUrl && serviceUrl && cbUrl.host === serviceUrl.host) {
            logger(['info', 'auth', 'saml'], `User ${credentials.sub} authenticated successfully`)
            h.state('P_SESSION', token, {encoding: 'none', ttl: options.sessionTime * 1000, isSameSite: 'Strict', path: '/'})
            h.state('P_INFO', Buffer.from(JSON.stringify({ twoFactor: false, roles: credentials.roles })).toString('base64'), {encoding: 'none', ttl: options.sessionTime * 1000, isSameSite: 'Strict', path: '/', isHttpOnly: false})
            return resolve(h.redirect(request.payload['RelayState']))
          } else {
            return reject(errorWithKey('invalid-redirect', {
              tags: ['error', 'auth', 'saml'],
              metadata: { username: credentials.username, callbackUrl: cbUrl },
              ctx: {}
            }))
          }
        } catch (err) {
          return reject(err)
        }
      })
    })
  }
}

const config = {
  description: 'Validate saml',
  cache: {
    privacy: 'private',
    expiresIn: 0
  },
  plugins: {
    'porg-auth': {
      type: 'no-auth'
    }
  }
}

export default { handler, config }
