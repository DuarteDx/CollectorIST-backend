import { getJwt } from '@/plugins/auth/services/JwtUtils'
import CAS from 'simple-cas-interface'
import Joi from 'joi'
import base64url from 'base64-url'
import URL from 'url-parse'
import { errorWithKey } from '@/plugins/errors'
import { logger } from 'papagaio'

const handler = (casOptions, options) => {
  return async (request, h) => {
    const opts = {
      ...casOptions
    }
    opts.serviceUrl = opts.serviceUrl + `/${request.params.callback}`
    const cas = new CAS(opts)
    const ticket = request.query.ticket
    if (!ticket) {
      throw errorWithKey('missing-ticket', {
        tags: ['error', 'auth', 'cas'],
        ctx: {}
      })
    }
    try {
      let result = await cas.validateServiceTicket(ticket)
      let credentials = await options.jwt.getPayloadForUsername({ username: result.user })
      if (credentials === null) {
        return h.redirect(options.cas.localAppUrl + options.unauthorizedPath)
      }
      const token = getJwt({
        payload: credentials,
        secretOrPrivateKey: options.jwt.secret,
        options: { expiresIn: options.sessionTime || 60 }
      })
      let callbackUrl = base64url.decode(request.params.callback)
      let cbUrl = new URL(callbackUrl)
      let serviceUrl = new URL(casOptions.serviceUrl)
      if (cbUrl && serviceUrl && cbUrl.host === serviceUrl.host) {
        logger(['info', 'auth', 'cas'], `User ${result.user} authenticated successfully`)

        h.state('P_SESSION', token, {encoding: 'none', ttl: options.sessionTime * 1000, isSameSite: 'Strict', path: '/'})
        h.state('P_INFO', Buffer.from(JSON.stringify({ twoFactor: false, roles: credentials.roles })).toString('base64'), {encoding: 'none', ttl: options.sessionTime * 1000, isSameSite: 'Strict', path: '/', isHttpOnly: false})
        return h.redirect(callbackUrl)
      } else {
        throw errorWithKey('invalid-redirect', {
          tags: ['error', 'auth', 'cas'],
          metadata: { username: result.user, callbackUrl: cbUrl, serviceUrl: casOptions.serviceUrl },
          ctx: {}
        })
      }
    } catch (err) {
      throw errorWithKey('not-authenticated', {
        tags: ['info', 'auth', 'cas'],
        cause: err.message,
        metadata: {},
        ctx: {}
      })
    }
  }
}

const config = {
  description: 'Validate a CAS ticket',
  cache: {
    privacy: 'private',
    expiresIn: 0
  },
  validate: {
    params: {
      callback: Joi.string().required()
    }
  },
  plugins: {
    'porg-auth': {
      type: 'no-auth'
    }
  }
}

export default { handler, config }
