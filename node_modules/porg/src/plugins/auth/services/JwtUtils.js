import jwt from 'jsonwebtoken'
import UserHasAnyTwoFactorAuth from '@/plugins/auth/services/UserHasAnyTwoFactorAuth'
import GetUserEnabledTwoFactors from '@/plugins/auth/services/GetUserEnabledTwoFactors'

export const jwtVerify = ({ authorization, options, authConfig }) => {
  return new Promise((resolve, reject) => {
    jwt.verify(authorization, options.jwt.secret, async (err, decoded) => {
      if (err) {
        return reject('not-authenticated')
      } else {
        const needsTwoFactor = options && options.twoFactor && authConfig && authConfig.twoFactor
        if (needsTwoFactor) {
          if (decoded.twoFactor) {
            return resolve({credentials: decoded})
          } else {
            const userAlreadyHasTwoAuth = await UserHasAnyTwoFactorAuth({ username: decoded.sub, getUserU2F: options.twoFactor.u2f.getUserU2F, getUserTOTP: options.twoFactor.totp.getUserTOTP })
            if (userAlreadyHasTwoAuth) {
              const userEnabledTwoFactors = await GetUserEnabledTwoFactors({ username: decoded.sub, getUserU2F: options.twoFactor.u2f.getUserU2F, getUserTOTP: options.twoFactor.totp.getUserTOTP })
              if (userEnabledTwoFactors.includes('u2f')) {
                return reject('requires-u2f-challenge')
              } else {
                return reject('requires-totp-challenge')
              }
            } else {
              return reject('requires-two-factor-registration')
            }
          }
        } else {
          return resolve({credentials: decoded})
        }
      }
    })
  })
}

export const getJwt = ({ payload, secretOrPrivateKey, options }) => {
  payload.sub = payload.username ? payload.username : payload.sub
  delete payload.username
  return jwt.sign(payload, secretOrPrivateKey, options)
}
