import Joi from 'joi'
import path from 'path'
import _ from 'underscore'
import { errorWithKey } from '@/plugins/errors'
import { logger } from 'papagaio'

import CasTicketValidation from '@/plugins/auth/controllers/cas/CasTicketValidation'
import RedirectToCas from '@/plugins/auth/controllers/cas/RedirectToCas'
import LogoutFromCAS from '@/plugins/auth/controllers/cas/LogoutFromCAS'

import SamlMetadata from '@/plugins/auth/controllers/saml/SamlMetadata'
import SamlRedirect from '@/plugins/auth/controllers/saml/SamlRedirect'
import SamlValidate from '@/plugins/auth/controllers/saml/SamlValidate'
import SamlLogout from '@/plugins/auth/controllers/saml/SamlLogout'
import SAMLUtils from '@/plugins/auth/services/SAMLUtils'

import GetU2FRegistrationChallenge from '@/plugins/auth/controllers/u2f/GetU2FRegistrationChallenge'
import SubmitU2FRegistrationChallenge from '@/plugins/auth/controllers/u2f/SubmitU2FRegistrationChallenge'
import GetU2FSignChallenge from '@/plugins/auth/controllers/u2f/GetU2FSignChallenge'
import SubmitU2FSignChallenge from '@/plugins/auth/controllers/u2f/SubmitU2FSignChallenge'

import RegisterTOTPSecretController from '@/plugins/auth/controllers/totp/RegisterTOTPSecretController'
import ConfirmTOTPRegistrationController from '@/plugins/auth/controllers/totp/ConfirmTOTPRegistrationController'
import SubmitTOTPChallengeController from '@/plugins/auth/controllers/totp/SubmitTOTPChallengeController'

import Logout2FA from '@/plugins/auth/controllers/common/Logout2FA'
import setupErrors from '@/plugins/auth/errors'

import { jwtVerify } from '@/plugins/auth/services/JwtUtils'

export let validateUserSessionCookies = function () {
  return false
}

const DSIAuthScheme = (server, options) => {
  const getAuthType = function () {
    return this.auth.credentials.type
  }
  const getPrincipal = function () {
    if (this.auth.isAuthenticated && this.auth.credentials.type === 'user-session') {
      const principal = {
        ...this.auth.credentials,
        username: this.auth.credentials.sub
      }
      delete principal.sub
      if (principal.iat) {
        delete principal.iat
      }
      if (principal.exp) {
        delete principal.exp
      }
      return principal
    } else {
      throw new Error('You must be in user-session')
    }
  }
  const principalHasRole = function (role) {
    if (this.auth.isAuthenticated && this.auth.credentials.type === 'user-session') {
      return this.auth.credentials.roles && this.auth.credentials.roles.includes(role)
    } else {
      throw new Error('You must be in user-session')
    }
  }
  const hasTwoFactor = function () {
    return !!this.auth.credentials.twoFactor
  }

  validateUserSessionCookies = async ({ request, jwtToken, authConfig }) => {
    const regularExpressionJwt = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/
    if (!regularExpressionJwt.test(jwtToken)) {
      return null
    }
    const auth = await jwtVerify({ authorization: jwtToken, options, authConfig })
    const requiredRoles = (authConfig && authConfig.roles) || options.defaultRequiredRoles
    const roles = auth.credentials && auth.credentials.roles ? auth.credentials.roles : []
    const missingRoles = _.difference(requiredRoles, roles)
    if (request && request.auth.error instanceof Error) {
      throw request.auth.error
    }
    if (missingRoles.length > 0) {
      throw errorWithKey('not-authorized', {
        ctx: {}
      })
    }
    auth.credentials.type = 'user-session'
    return auth
  }

  server.decorate('request', 'getAuthType', getAuthType)
  server.decorate('request', 'getPrincipal', getPrincipal)
  server.decorate('request', 'principalHasRole', principalHasRole)
  server.decorate('request', 'hasTwoFactor', hasTwoFactor)

  return {
    authenticate: async (request, h) => {
      let authConfigurations = []
      let pluginConfiguration = request.route.settings.plugins['porg-auth']
      if (!pluginConfiguration) {
        throw new Error('No porg auth in route')
      } else {
        authConfigurations = authConfigurations.concat(pluginConfiguration)
      }
      let type = 'not-authenticated'
      let ctx = {}
      let auth = {}
      for (let item in authConfigurations) {
        const authConfig = authConfigurations[item]
        switch (authConfig.type) {
          case 'user-session':
            if (!hasUserSession()) {
              throw new Error('This porg configuration doesnt support auth with user-session')
            }
            try {
              const jwtToken = request.state['P_SESSION']
              auth = await validateUserSessionCookies({ request, jwtToken, authConfig })
              if (!auth) {
                continue
              }
            } catch (err) {
              // If not authorized it must send message
              // Should be refactor to see if there is other authentication schema
              if (err.key === 'not-authorized') {
                throw err
              }
              type = err
              continue
            }
            return h.authenticated(auth)
          case 'static-bearer':
            if (!hasStaticBearer()) {
              throw new Error('This porg configuration doesnt support auth with static-bearer')
            }
            if (!authConfig.key) {
              throw new Error('A key must be defined when using static-bearer')
            }
            if (`Bearer ${options.staticBearer[authConfig.key]}` === request.raw.req.headers.authorization) {
              auth = {
                credentials: {
                  type: 'static-bearer',
                  key: authConfig.key
                }
              }
              return h.authenticated(auth)
            }
            break
          case 'no-auth':
            return h.authenticated({ credentials: { type: 'no-auth' } })
          default:
            type = 'unknown-auth-type'
            ctx = {
              type: authConfig.type
            }
        }
      }
      throw errorWithKey(type, { ctx })
    }
  }
}

const getCasOptions = (options) => {
  return {
    serverUrl: options.cas.serverUrl,
    serviceUrl: options.cas.localAppUrl + options.cas.ticketValidationEndpointPath,
    protocolVersion: options.cas.protocolVersion,
    method: options.cas.requestMethod,
    useGateway: options.cas.asGateway,
    strictSSL: options.cas.strictSSL
  }
}

const setAuthRedirectEndpoint = (server, options) => {
  let handler, config, logoutHandler, logoutConfig
  if (options.cas) {
    handler = RedirectToCas.handler(getCasOptions(options))
    config = RedirectToCas.config
    logoutHandler = LogoutFromCAS.handler(getCasOptions(options))
    logoutConfig = LogoutFromCAS.config
  } else {
    const samlOptions = {
      serviceUrl: options.saml.localAppUrl,
      ...SAMLUtils({
        sp: {
          assertUrl: options.saml.localAppUrl + '/api/v1/saml/validate',
          metadataUrl: options.saml.localAppUrl + '/api/v1/saml/metadata',
          privateKeyPath: options.saml.spPrivateKeyPath,
          certificatePath: options.saml.spCertificatePath
        },
        idp: {
          loginUrl: options.saml.loginUrl,
          logoutUrl: options.saml.logoutUrl,
          certificatePath: options.saml.idpCertificatePath
        }
      })
    }
    handler = SamlRedirect.handler({ samlOptions })
    config = SamlRedirect.config
    logoutHandler = SamlLogout.handler({ samlOptions })
    logoutConfig = SamlLogout.config
  }
  server.route({
    method: 'GET',
    path: options.redirectEndpointPath,
    handler,
    config
  })

  server.route({
    path: '/api/v1/logout',
    method: 'GET',
    handler: logoutHandler,
    config: logoutConfig
  })
}

const setupCASEndpoints = (server, options) => {
  const casOptions = getCasOptions(options)

  server.route({
    method: 'GET',
    path: path.join(options.cas.ticketValidationEndpointPath, '{callback}'),
    handler: CasTicketValidation.handler(casOptions, options),
    config: CasTicketValidation.config
  })
}

const setupSamlEndpoints = (server, options) => {
  const samlOptions = {
    serviceUrl: options.saml.localAppUrl,
    logoutRedirect: options.saml.logoutRedirect,
    ...SAMLUtils({
      sp: {
        assertUrl: options.saml.localAppUrl + '/api/v1/saml/validate',
        metadataUrl: options.saml.localAppUrl + '/api/v1/saml/metadata',
        privateKeyPath: options.saml.spPrivateKeyPath,
        certificatePath: options.saml.spCertificatePath
      },
      idp: {
        loginUrl: options.saml.loginUrl,
        logoutUrl: options.saml.logoutUrl,
        certificatePath: options.saml.idpCertificatePath
      }
    })
  }

  server.route({
    method: 'GET',
    path: '/api/v1/saml/metadata',
    handler: SamlMetadata.handler({ samlOptions, options }),
    config: SamlMetadata.config
  })

  server.route({
    method: 'GET',
    path: '/api/v1/saml/validate',
    handler: SamlLogout.handler({ samlOptions }),
    config: SamlLogout.config
  })

  server.route({
    method: 'POST',
    path: '/api/v1/saml/validate',
    handler: SamlValidate.handler({ samlOptions, options }),
    config: SamlValidate.config
  })

  server.route({
    method: 'GET',
    path: '/api/v1/saml/logout',
    handler: SamlLogout.handler({ samlOptions, options }),
    config: SamlLogout.config
  })
}

const setupTOTPEndpoints = (server, options) => {
  if (options.twoFactor.totp) {
    server.route({
      path: '/api/v1/totp-registration',
      method: 'POST',
      handler: RegisterTOTPSecretController.handler(options),
      config: RegisterTOTPSecretController.config
    })

    server.route({
      path: '/api/v1/totp-confirmation',
      method: 'POST',
      handler: ConfirmTOTPRegistrationController.handler(options),
      config: ConfirmTOTPRegistrationController.config
    })

    server.route({
      path: '/api/v1/totp-challenge',
      method: 'POST',
      handler: SubmitTOTPChallengeController.handler(options),
      config: SubmitTOTPChallengeController.config
    })
  }
}

const setupTwoFactorEndPoints = (server, options) => {
  if (options.twoFactor.u2f) {
    server.route({
      path: '/api/v1/u2f-registration',
      method: 'GET',
      handler: GetU2FRegistrationChallenge.handler(options),
      config: GetU2FRegistrationChallenge.config
    })

    server.route({
      path: '/api/v1/u2f-registration',
      method: 'POST',
      handler: SubmitU2FRegistrationChallenge.handler(options),
      config: SubmitU2FRegistrationChallenge.config
    })

    server.route({
      path: '/api/v1/u2f-sign-challenge',
      method: 'GET',
      handler: GetU2FSignChallenge.handler(options),
      config: GetU2FSignChallenge.config
    })

    server.route({
      path: '/api/v1/u2f-sign-challenge',
      method: 'POST',
      handler: SubmitU2FSignChallenge.handler(options),
      config: SubmitU2FSignChallenge.config
    })
  }
}

export let hasUserSession = () => {
  throw new Error('hasUserSession is not defined')
}

export let hasStaticBearer = () => {
  throw new Error('hasStaticBearer is not defined')
}

export let hasStaticBearerKey = (key) => {
  throw new Error('getStaticBearerKeys is not defined')
}

export let hasTwoFactor = () => {
  throw new Error('hasTwoFactor is not defined')
}

export const plugin = {
  name: 'auth-plugin',
  version: '1.0.0',
  register: async function (server, options) {
    try {
      logger(['info', 'server', 'porg-auth'], `Init config porg-auth`)
      const optionsSchema = Joi.object().keys({
        staticBearer: Joi.object().pattern(/^/, Joi.string()),
        redirectEndpointPath: Joi.string().regex(/^\/[\w\W\/]+\/?$/).default('/api/v1/authenticate'),
        unauthorizedPath: Joi.string().default('/unauthorized'),
        cas: {
          serverUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
          protocolVersion: Joi.number().valid([1, 2, 3]).default(2.0),
          requestMethod: Joi.string().valid(['GET', 'POST']).default('GET'),
          asGateway: Joi.boolean().default(false),
          localAppUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
          ticketValidationEndpointPath: Joi.string().regex(/^\/[\w\W\/]+\/?$/).default('/api/v1/cas-st-handler'),
          strictSSL: Joi.boolean().default(true),
          saveRawCAS: Joi.boolean().default(false)
        },
        saml: {
          localAppUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
          loginUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
          logoutUrl: Joi.string().uri({scheme: ['http', 'https']}).required(),
          logoutRedirect: Joi.string().uri({scheme: ['http', 'https']}).required(),
          spCertificatePath: Joi.string().required(),
          spPrivateKeyPath: Joi.string().required(),
          idpCertificatePath: Joi.string().required()
        },
        autoRegister: Joi.boolean().default(true),
        sessionTime: Joi.number().default(3600),
        jwt: {
          getPayloadForUsername: Joi.func().required(),
          secret: Joi.string().required()
        },
        defaultRequiredRoles: Joi.array().default([]),
        twoFactor: {
          sessionTime: Joi.number().default(1200),
          u2f: Joi.object().keys({
            appId: Joi.string().required(),
            getUserU2F: Joi.func().required(),
            saveUserU2FChallenge: Joi.func().required(),
            upsertUserU2F: Joi.func().required()
          }),
          totp: Joi.object().keys({
            service: Joi.string().required(),
            getUserTOTP: Joi.func().required(),
            confirmUserTOTP: Joi.func().required(),
            upsertUserTOTP: Joi.func().required(),
            digits: Joi.number().integer().valid([6, 8]).default(6)
          })
        }
      })
      setupErrors()
      const validation = Joi.validate(options, optionsSchema)
      if (validation.error) {
        throw new Error(validation.error)
      }

      hasUserSession = () => {
        return (validation.value.cas !== undefined || validation.value.saml !== undefined) && validation.value.jwt !== undefined
      }

      hasStaticBearer = () => {
        return validation.value.staticBearer !== undefined
      }
      hasStaticBearerKey = (key) => {
        return Object.keys(validation.value.staticBearer).includes(key)
      }
      hasTwoFactor = () => {
        return !!validation.value.twoFactor
      }
      server.auth.scheme('dsi-auth-scheme', DSIAuthScheme)
      if (validation.value.autoRegister) {
        server.auth.strategy('dsi-auth', 'dsi-auth-scheme', validation.value)
        if (hasUserSession()) {
          setAuthRedirectEndpoint(server, validation.value)
          if (validation.value.cas) {
            setupCASEndpoints(server, validation.value)
          } else {
            setupSamlEndpoints(server, validation.value)
          }

          if (hasTwoFactor()) {
            setupTOTPEndpoints(server, validation.value)
            setupTwoFactorEndPoints(server, validation.value)
            server.route({
              path: '/api/v1/logout/2fa',
              method: 'GET',
              handler: Logout2FA.handler(validation.value),
              config: Logout2FA.config
            })
          }
        }
      }
      logger(['info', 'server', 'porg-auth'], `End config porg-auth`)
    } catch (err) {
      logger(['err', 'server', 'porg-auth'], err.message)
    }
  }
}
