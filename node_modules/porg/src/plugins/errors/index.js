import Joi from 'joi'
import { logger, configLogger, levels } from 'papagaio'
import setupErrorsInternal from '@/plugins/errors/internal-errors'
import uuid from 'uuid/v1'

const noSetupErrors = (setupError) => {
  logger(['info', 'papagaio'], 'No error setup function was provided...')
}

let errorMap = {}

class Arrrggg extends Error {
  constructor ({ key, tags, cause, statusCode, metadata, ctx, stack }) {
    super(cause)
    this.key = key
    this.statusCode = statusCode
    this.cause = cause
    this.stack = stack
    this.ctx = ctx
    this.metadata = metadata
    this.tags = tags
  }

  getTags () {
    return this.tags
  }

  getKey () {
    return this.key
  }

  getStatusCode () {
    return this.statusCode
  }

  getCause () {
    return this.cause
  }

  // Ctx to help string templating of the error message
  getCtx () {
    return this.ctx
  }

  // Metadata goes to logs
  getMetadata () {
    return this.metadata
  }
}

const hasLogLevelInArray = (tags) => {
  for (let tag of tags) {
    if (levels[tag] !== undefined) {
      return true
    }
  }
  return false
}

const setupError = ({ key, statusCode, translations }) => {
  if (statusCode < 400 || statusCode >= 500) {
    throw new Error('SetupError can only be used for 400 status code')
  }
  errorMap[key] = {
    translations,
    error: ({ tags, ctx, metadata, cause, stack }) => {
      tags.push(key)
      if (!hasLogLevelInArray(tags)) {
        tags.push('info')
      }
      const message = stack ? `${cause || key}\n${stack}` : cause || key
      logger(tags, message, metadata)
      return new Arrrggg({
        tags,
        key,
        ctx,
        metadata,
        cause,
        statusCode,
        stack
      })
    }
  }
}

const setupErrorInternal = ({ key }) => {
  errorMap[key] = {
    translations: {
      en: 'Internal Server Error',
      pt: 'Erro Interno'
    },
    error: ({ tags, ctx, metadata, cause, stack }) => {
      tags.push(key)
      if (!hasLogLevelInArray(tags)) {
        tags.push('alert')
      }
      const hash = uuid()
      ctx = ctx || {}
      metadata = metadata || {}
      ctx['$error_hash'] = hash
      metadata['$error_hash'] = hash
      const message = stack ? `${cause || key}\n${stack}` : cause || key
      logger(tags, message, metadata)
      return new Arrrggg({
        tags,
        key: 'internal-error',
        ctx,
        metadata,
        cause,
        stack,
        statusCode: 500
      })
    }
  }
}

const errorWithKey = (key, params) => {
  const errorEntry = errorMap[key]
  if (typeof params !== 'object' || !(params.tags instanceof Array)) {
    params = { tags: [] }
  }
  if (errorEntry) {
    if (!params.stack && !params.stackDisabled) {
      const myObject = new Error(key)
      Error.captureStackTrace(myObject, errorWithKey)
      params.stack = myObject.stack
    }
    return errorEntry.error(params)
  } else {
    throw new Error(`No error was defined for key ${key}`)
  }
}

const schema = Joi.object().keys({
  urlPath: Joi.string().default('/api/v1/errors'),
  papagaio: Joi.object().default({}),
  setupApplicationErrors: Joi.func().default(noSetupErrors)
})

const errorSchema = Joi.object().keys({
  error: Joi.any().optional(),
  key: Joi.string().required(),
  ctx: Joi.object().default({}),
  metadata: Joi.object().default({}),
  cause: Joi.string().default('An unknown error has occurred'),
  statusCode: Joi.number().integer().required()
})

const plugin = {
  name: 'errors-plugin',
  version: '1.0.0',
  register: async function (server, options) {
    logger(['info', 'server', 'logging'], `Init config logging`)
    const validation = Joi.validate(options, schema)
    if (validation.error) {
      throw new Error(validation.error)
    }

    setupErrorsInternal()
    const optionsErrors = validation.value
    optionsErrors.setupApplicationErrors()

    const handleError = function (error, h) {
      try {
        if (error.output && error.output.statusCode === 404) { // Handles error throwed by hapi when a route doesn't exist
          error = errorWithKey('_route-not-found', { tags: ['porg', 'warn'], ctx: {}, cause: `Route not found: ${h.request.method.toUpperCase()}: ${h.request.url.path}`, stackDisabled: true })
        } else if (!(error instanceof Arrrggg)) { // Handles unhandled errors errors
          error = errorWithKey('internal-error', { tags: ['porg', 'emerg'], ctx: {}, cause: error.message, stack: error.stack })
        }

        const validation = Joi.validate(error, errorSchema, {stripUnknown: true})
        if (validation.error) {
          error = errorWithKey('errors-error', { tags: ['porg', 'emerg'], ctx: {}, cause: error.message })
          return h.response({key: error.key, ctx: error.ctx}).code(error.statusCode)
        } else {
          return h.response({key: validation.value.key, ctx: validation.value.ctx}).code(validation.value.statusCode)
        }
      } catch (err) {
        logger(['emerg', 'log'], err.message)
      }
    }

    server.route({
      path: optionsErrors.urlPath,
      method: 'GET',
      handler: async (request, h) => {
        const result = {}
        Object.keys(errorMap).forEach((key) => {
          result[key] = errorMap[key].translations[request.query.lang]
        })
        return result
      },
      config: {
        validate: {
          query: {
            lang: Joi.string().valid(['pt', 'en']).default('pt')
          }
        },
        plugins: {
          'porg-auth': {
            type: 'no-auth'
          }
        }
      }
    })

    const preResponse = function (request, h) {
      if (request.response instanceof Error) {
        return handleError(request.response, h)
      } else {
        return h.continue
      }
    }
    server.ext('onPreResponse', preResponse)
    logger(['info', 'server', 'logging'], `End config logging`)
  }
}

const resetMapErrors = () => {
  errorMap = {}
}

export { plugin, errorWithKey, logger, setupError, configLogger, setupErrorInternal, resetMapErrors }
