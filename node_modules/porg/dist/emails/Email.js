'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendByDrive = exports.Email = exports.setConfigEmail = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _papagaio = require('papagaio');

var _drivers = require('../drivers');

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _providers = require('../providers');

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _nunjucks = require('nunjucks');

var _nunjucks2 = _interopRequireDefault(_nunjucks);

var _ = require('./..');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const commonSchema = _joi2.default.object().keys({
  from: _joi2.default.string().required(),
  to: _joi2.default.string().required(),
  deliveryTime: _joi2.default.date(),
  expireTime: _joi2.default.date()
});

const emailSchema = commonSchema.keys({
  subject: _joi2.default.string().required(),
  text: _joi2.default.string(),
  html: _joi2.default.string()
}).or('text', 'html');

const emailTemplateSchema = commonSchema.keys({
  template: _joi2.default.string().required(),
  context: _joi2.default.object().required(),
  locale: _joi2.default.string().required()
});

let templateMapGlobal, templatePathGlobal;

const validateTime = mailOptions => {
  const now = (0, _moment2.default)();
  if (!mailOptions.deliveryTime) {
    mailOptions.deliveryTime = now.toDate();
  }
  if (!mailOptions.expireTime) {
    mailOptions.expireTime = now.add(1, 'hours').toDate();
  }

  if ((0, _moment2.default)(mailOptions.expireTime).isBefore((0, _moment2.default)(mailOptions.deliveryTime))) {
    throw new Error('Invalid error time');
  }
};

const sendSmtp = mailOptions => {
  return new Promise((resolve, reject) => {
    for (let key in mailOptions) {
      // Clean keys with null elements
      if (!mailOptions[key]) {
        delete mailOptions[key];
      }
    }
    const validation = _joi2.default.validate(mailOptions, emailSchema);
    if (validation.error) {
      (0, _papagaio.logger)(['porg', 'mail', 'notice'], `Invalid format sending email`);
      return reject(new Error(validation.error));
    }
    validateTime(validation.value);
    _drivers.Smtp.transporter.sendMail(validation.value, (error, info) => {
      if (error) {
        (0, _papagaio.logger)(['porg', 'mail', 'notice'], `Error sending email`);
        return reject(error);
      }
      (0, _papagaio.logger)(['porg', 'mail', 'info'], JSON.stringify(info));
      return resolve(info.messageId);
    });
  });
};

let sendByDrive;

const sendPersistance = persistanceProvider => {
  return (() => {
    var _ref = _asyncToGenerator(function* (mailOptions) {
      const validation = _joi2.default.validate(mailOptions, emailSchema);
      if (validation.error) {
        (0, _papagaio.logger)(['porg', 'mail', 'notice'], `Invalid format sending email`);
        throw new Error(validation.error);
      }
      validateTime(validation.value);
      yield persistanceProvider.insertEmail(validation.value);
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  })();
};

const renderTemplate = ({ template, context, locale }) => {
  const result = {
    subject: null,
    text: null,
    html: null
  };
  (0, _papagaio.logger)(['info', 'email-service', 'porg'], `Configuring email templates path to ${templatePathGlobal}`);
  const env = _nunjucks2.default.configure(templatePathGlobal, {

    autoescape: true, throwOnUndefined: true
  });
  let localAppUrl = `${_.config.application.protocol}://${_.config.application.host}`;
  if (_.config.application.protocol.toLowerCase() === 'https' && _.config.application.frontendPort !== 443 || _.config.application.protocol.toLowerCase() === 'http' && _.config.application.frontendPort !== 80) {
    localAppUrl = `${localAppUrl}:${_.config.application.frontendPort}`;
  }
  env.addGlobal('app', {
    baseURL: localAppUrl
  });
  try {
    const subjectKey = `${template}_subject_${locale}`;
    const subjectTemplate = templateMapGlobal[subjectKey];
    if (!subjectTemplate) {
      throw new Error(`No template for subject found ${subjectKey}`);
    }
    result.subject = env.renderString(subjectTemplate, context);
    const textBodyKey = `${template}_body_text_${locale}`;
    const textBodyTemplate = templateMapGlobal[textBodyKey];
    if (!textBodyKey) {
      throw new Error(`No template for body found ${subjectKey}`);
    }
    result.text = env.renderString(textBodyTemplate, context);
    const htmlBodyKey = `${template}_body_html_${locale}`;
    const htmlBodyTemplate = templateMapGlobal[htmlBodyKey];
    if (htmlBodyTemplate) {
      result.html = env.renderString(htmlBodyTemplate, context);
    }
    return result;
  } catch (err) {
    console.log({ err });
    throw err;
  }
};

let Email = {
  send() {
    throw new Error('Mail not configured');
  },
  sendWithTemplate(mailOptions) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const validation = _joi2.default.validate(mailOptions, emailTemplateSchema);
      if (validation.error) {
        (0, _papagaio.logger)(['porg', 'mail', 'notice'], `Invalid format sending email`);
        throw new Error(validation.error);
      }
      const email = _extends({
        from: mailOptions.from,
        to: mailOptions.to
      }, renderTemplate({ template: validation.value.template, context: validation.value.context, locale: validation.value.locale }));
      if (mailOptions.deliveryTime) {
        email.deliveryTime = mailOptions.deliveryTime;
      }
      if (mailOptions.expireTime) {
        email.expireTime = mailOptions.expireTime;
      }
      _this.send(email);
    })();
  }
};
const setConfigEmail = ({ emailConfig, templateMap, templatePath }) => {
  templateMapGlobal = templateMap;
  templatePathGlobal = templatePath;
  if (emailConfig.throttling) {
    Email.send = sendPersistance((0, _providers.getEmailProvider)({ name: emailConfig.throttling.persistenceProvider }));
    exports.sendByDrive = sendByDrive = sendSmtp;
  } else {
    if (emailConfig.driver === 'smtp') {
      Email.send = sendSmtp;
    }
  }
};

exports.setConfigEmail = setConfigEmail;
exports.Email = Email;
exports.sendByDrive = sendByDrive;