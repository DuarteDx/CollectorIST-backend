'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = require('path');

var path = _interopRequireWildcard(_path);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _os = require('os');

var os = _interopRequireWildcard(_os);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _errors = require('../../plugins/errors');

var _UploadSessionState = require('../constants/UploadSessionState');

var _UploadSessionState2 = _interopRequireDefault(_UploadSessionState);

var _cryptoJs = require('crypto-js');

var _cryptoJs2 = _interopRequireDefault(_cryptoJs);

var _fileType = require('file-type');

var _fileType2 = _interopRequireDefault(_fileType);

var _FilePath = require('../util/FilePath');

var _FilePath2 = _interopRequireDefault(_FilePath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const writeFileToDisk = ({ file, filePath, extension, mimeTypes }) => {
  _mkdirp2.default.sync(path.dirname(filePath));
  return new Promise((resolve, reject) => {
    const filePersistence = fs.createWriteStream(filePath);
    filePersistence.on('error', err => {
      reject(err);
    });

    let hash = _cryptoJs2.default.algo.SHA256.create();
    let dataLength = 0;
    let isValidFile = false;
    file.pipe(filePersistence);
    file.on('data', chunk => {
      if (!isValidFile) {
        const ft = (0, _fileType2.default)(chunk);
        if (ft && mimeTypes) {
          // reject file if mime or extension mismatch
          if (!mimeTypes.includes(ft.mime) || ft.ext !== extension.slice(1)) {
            file.emit('error', (0, _errors.errorWithKey)('invalid-file', {}));
          } else {
            isValidFile = true;
          }
        }
      }
      dataLength += chunk.length;
      hash.update(_cryptoJs2.default.lib.WordArray.create(chunk));
    }).on('end', _asyncToGenerator(function* () {
      return resolve({ checksum: hash.finalize().toString(), fileSize: dataLength });
    })).on('error', error => {
      deleteFile({ filePath });
      return reject(error);
    });
  });
};

function deleteFile({ filePath }) {
  if (fs.existsSync(filePath)) {
    fs.unlinkSync(filePath);
  }
}

const getChecksumFromChunk = ({ filePath, start, end }) => {
  const readStream = fs.createReadStream(filePath, { start, end });
  return new Promise((resolve, reject) => {
    let hash = _cryptoJs2.default.algo.SHA256.create();
    readStream.on('data', function (chunk) {
      hash.update(_cryptoJs2.default.lib.WordArray.create(chunk));
    }).on('end', function () {
      return resolve(hash.finalize().toString());
    }).on('error', error => {
      return reject(error);
    });
  });
};

const generateChallenges = (() => {
  var _ref2 = _asyncToGenerator(function* ({ filePath, fileSize }) {
    const totalChallenges = Math.ceil(Math.min(30, fileSize * 0.001));
    let indexes = [];
    let lastRandom = -1;
    let newRandom;
    while (indexes.length < totalChallenges * 2) {
      newRandom = Math.floor(Math.random() * fileSize);
      if (newRandom !== lastRandom) {
        indexes.push(newRandom);
      }
    }
    let challenges = [];
    for (let i = 0; i < indexes.length; i++) {
      if (i % 2 === 0) {
        const range = indexes.slice(i, i + 2).sort(function (e1, e2) {
          return e1 - e2;
        });
        let challenge = { start: range[0], end: range[1] };
        const chunkChecksum = yield getChecksumFromChunk(_extends({ filePath }, challenge));
        challenge.checksum = chunkChecksum;
        challenges.push(challenge);
      }
    }
    return challenges;
  });

  return function generateChallenges(_x) {
    return _ref2.apply(this, arguments);
  };
})();

exports.default = (() => {
  var _ref3 = _asyncToGenerator(function* ({ persistenceProvider, StorageProvider, tempStorageRootPath, mimeTypes, deduplication, session, file }) {
    // Fail fast verification
    if (!file || mimeTypes && !mimeTypes.includes(file.hapi.headers['content-type'])) {
      throw (0, _errors.errorWithKey)('invalid-file', {});
    }

    let uploadSession = yield persistenceProvider.getUploadSession({ id: session });

    if (!uploadSession || uploadSession.state !== _UploadSessionState2.default.WAITING_FOR_FILE) {
      throw (0, _errors.errorWithKey)('upload-session-not-found', {
        ctx: { id: session }
      });
    }
    const extension = path.extname(file.hapi.filename);
    const filename = session + extension;

    const newFile = {
      _id: session,
      originalFilename: file.hapi.filename,
      filename
    };
    const tempFilePath = path.join(tempStorageRootPath || os.tmpdir(), filename);
    try {
      const { checksum, fileSize } = yield writeFileToDisk({ file, filePath: tempFilePath, extension, mimeTypes });
      newFile.checksum = checksum;
      newFile.size = fileSize;
      if (deduplication) {
        newFile.challenges = yield generateChallenges({ filePath: tempFilePath, fileSize: newFile.size });
      }
      const folderTree = _FilePath2.default.getExpandedPathTree({ value: session, folderNameSize: 3 });
      const relativeFilePath = path.join(...folderTree, filename);
      yield StorageProvider.storeFile({ file: fs.createReadStream(tempFilePath), filePath: relativeFilePath });
    } catch (err) {
      throw (0, _errors.errorWithKey)('internal-error', { tags: ['emerg', 'porg'], cause: JSON.stringify(err) });
    }

    yield persistenceProvider.insertFile({ file: newFile });
    yield persistenceProvider.setUploadSessionState({ id: session, state: _UploadSessionState2.default.FILE_RECEIVED });
    return { id: newFile._id };
  });

  return function (_x2) {
    return _ref3.apply(this, arguments);
  };
})();

module.exports = exports['default'];