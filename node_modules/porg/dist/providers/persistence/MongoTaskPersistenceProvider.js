'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MongoDB = require('../../drivers/MongoDB');

var _StatusTask = require('../../tasks/StatusTask');

var _StatusTask2 = _interopRequireDefault(_StatusTask);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

class MongoTaskPersistenceProvider {
  addTask({ taskName, execution, cron, version, executionTimeLimit, defaultInput }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const taskDb = yield db.collection('porg-tasks').findOne({ _id: taskName });
      if (taskDb) {
        if (taskDb.version === version) {
          return false;
        } else {
          yield db.collection('porg-tasks').findOneAndUpdate({ _id: taskName }, { $set: { type: 'src', execution, cron, version, executionTimeLimit, defaultInput } }, { upsert: true });
          return true;
        }
      } else {
        yield db.collection('porg-tasks').insertOne({ _id: taskName, type: 'src', execution, cron, version, executionTimeLimit, defaultInput });
        return true;
      }
    })();
  }

  addTaskSource({ taskName, execution, cron, version, executionTimeLimit, defaultInput, src }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const taskDb = yield db.collection('porg-tasks').findOne({ _id: taskName });
      if (taskDb) {
        if (taskDb.version === version) {
          return false;
        } else {
          yield db.collection('porg-tasks').findOneAndUpdate({ _id: taskName }, { $set: { type: 'database', execution, cron, version, executionTimeLimit, src, defaultInput } }, { upsert: true });
          return true;
        }
      } else {
        yield db.collection('porg-tasks').insertOne({ _id: taskName, type: 'database', execution, cron, version, executionTimeLimit, src, defaultInput });
        return true;
      }
    })();
  }

  getTasks() {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const tasks = yield db.collection('porg-tasks').find().toArray();
      return tasks.map(function (t) {
        return {
          id: t._id,
          type: t.type,
          execution: t.execution,
          cron: t.cron,
          version: t.version,
          executionTimeLimit: t.executionTimeLimit,
          src: t.src,
          defaultInput: t.defaultInput
        };
      });
    })();
  }

  getTask({ taskName }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const task = yield db.collection('porg-tasks').findOne({ _id: taskName });
      return {
        id: task._id,
        type: task.type,
        execution: task.execution,
        cron: task.cron,
        version: task.version,
        src: task.src,
        executionTimeLimit: task.executionTimeLimit,
        defaultInput: task.defaultInput
      };
    })();
  }

  createTaskInstance({ id, name, date, executionTimeLimit, input }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      yield db.collection('porg-tasks-instances').insertOne({ '_id': id, name, date, status: _StatusTask2.default.Pending, executionTimeLimit, input, percentage: 0, text: '', killswitch: false });
    })();
  }

  updateTaskInstance({ id, status, message, startDate, endDate, percentage, text, pid, platform, hostname, killswitch, executionTimeLimit, locks }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const update = {};
      if (status) {
        update['status'] = status;
      }
      if (message) {
        update['message'] = message;
      }
      if (startDate) {
        update['startDate'] = startDate;
      }
      if (endDate) {
        update['endDate'] = endDate;
      }
      if (percentage !== undefined) {
        // with undefined because 0 is false
        update['percentage'] = percentage;
      }
      if (text !== undefined) {
        // with undefined because '' is false
        update['text'] = text;
      }
      if (pid !== undefined) {
        // with undefined because '' is false
        update['pid'] = pid;
      }
      if (platform !== undefined) {
        // with undefined because '' is false
        update['platform'] = platform;
      }
      if (hostname !== undefined) {
        // with undefined because '' is false
        update['hostname'] = hostname;
      }
      if (killswitch !== undefined) {
        // with undefined because '' is false
        update['killswitch'] = killswitch;
      }
      if (executionTimeLimit !== undefined) {
        // with undefined because '' is false
        update['executionTimeLimit'] = executionTimeLimit;
      }
      if (locks !== undefined) {
        // with undefined because '' is false
        update['locks'] = locks;
      }
      yield db.collection('porg-tasks-instances').findOneAndUpdate({ _id: id }, { '$set': update });
    })();
  }

  getTasksInstances({ status }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const tasks = yield db.collection('porg-tasks-instances').find({ status }).toArray();
      return tasks.map(function (t) {
        return {
          id: t._id,
          name: t.name,
          date: t.date,
          status: t.status,
          executionTimeLimit: t.executionTimeLimit,
          startDate: t.startDate,
          endDate: t.endDate,
          message: t.message,
          input: t.input,
          text: t.text,
          percentage: t.percentage,
          pid: t.pid,
          platform: t.platform,
          hostname: t.hostname,
          killswitch: t.killswitch,
          locks: t.locks
        };
      });
    })();
  }

  getTaskInstanceById({ id }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const t = yield db.collection('porg-tasks-instances').findOne({ _id: id });
      if (t) {
        return {
          id: t._id,
          name: t.name,
          date: t.date,
          status: t.status,
          executionTimeLimit: t.executionTimeLimit,
          startDate: t.startDate,
          endDate: t.endDate,
          message: t.message,
          input: t.input,
          text: t.text,
          percentage: t.percentage,
          pid: t.pid,
          platform: t.platform,
          hostname: t.hostname,
          killswitch: t.killswitch,
          locks: t.locks
        };
      } else {
        return null;
      }
    })();
  }

  getTaskInstances({ name, status }) {
    return _asyncToGenerator(function* () {
      const db = yield (0, _MongoDB.getDB)();
      const tasks = yield db.collection('porg-tasks-instances').find({ name, status }).sort({ date: 1 }).toArray();
      return tasks.map(function (t) {
        return {
          id: t._id,
          name: t.name,
          date: t.date,
          status: t.status,
          input: t.input,
          percentage: t.percentage
        };
      });
    })();
  }
}
exports.default = MongoTaskPersistenceProvider;
module.exports = exports['default'];