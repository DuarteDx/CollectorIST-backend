'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _hapi = require('hapi');

var _hapi2 = _interopRequireDefault(_hapi);

var _routes = require('./routes');

var _routes2 = _interopRequireDefault(_routes);

var _plugins = require('./plugins');

var _plugins2 = _interopRequireDefault(_plugins);

var _auth = require('./plugins/auth');

var _providers = require('./providers');

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _papagaio = require('papagaio');

var _errors = require('./plugins/errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

let basePath;
const createServer = ({ config }) => {
  basePath = _path2.default.dirname(require.main.filename);
  if (config.nodeStartPath) {
    basePath = _path2.default.resolve(basePath, config.nodeStartPath);
  }

  let https = {};
  if (config.application.tls) {
    https = { tls: {
        'key': _fs2.default.readFileSync(config.application.tls.key),
        'cert': _fs2.default.readFileSync(config.application.tls.cert)
      } };
  }

  const serverOptions = _extends({
    'port': config.application.backendPort,
    'routes': {
      'auth': {
        'strategy': 'dsi-auth',
        'mode': 'required'
      },
      'validate': {
        'failAction': (() => {
          var _ref = _asyncToGenerator(function* (request, h, err) {
            // Refactor to plugin hapi-papagaio
            // This catches validations errors on all routes of hapi.js and disables the useless stacktrace
            throw (0, _errors.errorWithKey)('validation-error', { tags: ['warn'], cause: `${err.message}\nRequest Url Path: ${request.url.path}`, stackDisabled: true });
          });

          return function failAction(_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        })()
      }
    }
  }, https);
  const server = _hapi2.default.server(serverOptions);
  return server;
};

const processAuthPlugin = (() => {
  var _ref2 = _asyncToGenerator(function* ({ config }) {
    let userAuthProvider;
    let auth;
    if (config.auth && (config.auth.userSession || config.auth.staticBearer)) {
      auth = {};
      if (config.auth.staticBearer) {
        auth.staticBearer = config.auth.staticBearer;
      }

      if (config.auth.userSession) {
        auth.sessionTime = config.auth.userSession.singleSignOn.sessionTime;
        auth.unauthorizedPath = config.auth.userSession.unauthorizedPath;
        const getClaimsFromAuthenticationContextScriptPath = _path2.default.join(basePath, 'services', 'authentication', 'GetClaimsFromAuthenticationContext.js');
        if (!_fs2.default.existsSync(getClaimsFromAuthenticationContextScriptPath)) {
          throw new Error(`Missing GetClaimsFromAuthenticationContext script at ${getClaimsFromAuthenticationContextScriptPath}`);
        }
        let localAppUrl = `${config.application.protocol}://${config.application.host}`;
        if (config.application.protocol.toLowerCase() === 'https' && config.application.frontendPort !== 443 || config.application.protocol.toLowerCase() === 'http' && config.application.frontendPort !== 80) {
          localAppUrl = `${localAppUrl}:${config.application.frontendPort}`;
        }
        if (config.auth.userSession.singleSignOn.type.cas) {
          auth.cas = {
            'serverUrl': config.auth.userSession.singleSignOn.type.cas.serverUrl,
            'localAppUrl': localAppUrl,
            'strictSSL': config.auth.userSession.singleSignOn.type.cas.strictSsl
          };
        } else if (config.auth.userSession.singleSignOn.type.saml) {
          auth.saml = _extends({}, config.auth.userSession.singleSignOn.type.saml, {
            'localAppUrl': localAppUrl
          });
        } else {
          throw new Error('No authentication mechanism (CAS or SAML) configured.');
        }

        auth.jwt = {
          'getPayloadForUsername': require(getClaimsFromAuthenticationContextScriptPath),
          'secret': config.auth.userSession.singleSignOn.jwt.secret
        };
        if (config.auth.userSession.twoFactor) {
          userAuthProvider = (0, _providers.getUserAuthProvider)({ name: config.auth.userSession.twoFactor.persistenceProvider });
          const twoFactor = {
            'sessionTime': config.auth.userSession.twoFactor.sessionTime
          };

          if (config.auth.userSession.twoFactor.modes.includes('u2f')) {
            twoFactor.u2f = {
              'getUserU2F': userAuthProvider.getU2FForUsername,
              'saveUserU2FChallenge': userAuthProvider.createOrUpdateAuthorU2FAuth,
              'upsertUserU2F': userAuthProvider.createOrUpdateAuthorU2FAuthRequest,
              'appId': localAppUrl
            };
          }

          if (config.auth.userSession.twoFactor.modes.includes('totp')) {
            twoFactor.totp = {
              'service': config.application.name,
              'upsertUserTOTP': userAuthProvider.registerTOTPSecretForUsername,
              'confirmUserTOTP': userAuthProvider.confirmTOTPSecretForUsername,
              'getUserTOTP': userAuthProvider.getTOTPForUsername
            };
          }
          auth.twoFactor = twoFactor;
        }
      }
    } else {
      auth = {};
    }
    return {
      plugin: require('./plugins/auth'),
      options: auth
    };
  });

  return function processAuthPlugin(_x4) {
    return _ref2.apply(this, arguments);
  };
})();

const processLoggingPlugin = (() => {
  var _ref3 = _asyncToGenerator(function* ({ config }) {
    const setupApplicationErrorsScriptPath = _path2.default.join(basePath, 'errors', 'index.js');
    let setupApplicationErrors;
    if (_fs2.default.existsSync(setupApplicationErrorsScriptPath)) {
      setupApplicationErrors = require(setupApplicationErrorsScriptPath);
    } else {
      setupApplicationErrors = function () {
        (0, _papagaio.logger)(['warn', 'porg'], 'No src/errors/index.js was found, no user errors defined');
      };
    }
    return {
      plugin: require('./plugins/errors'),
      options: {
        'urlPath': config.errors.localeEndpoint,
        'setupApplicationErrors': setupApplicationErrors,
        'papagaio': config.papagaio
      }
    };
  });

  return function processLoggingPlugin(_x5) {
    return _ref3.apply(this, arguments);
  };
})();

const processMetricsPlugin = (() => {
  var _ref4 = _asyncToGenerator(function* ({ config }) {
    return {
      plugin: require('./plugins/metrics'),
      options: config.metrics,
      routes: {
        prefix: config.metrics.endpoint
      }
    };
  });

  return function processMetricsPlugin(_x6) {
    return _ref4.apply(this, arguments);
  };
})();

const processHealthcheckPlugin = (() => {
  var _ref5 = _asyncToGenerator(function* ({ config }) {
    return {
      plugin: require('./plugins/healthcheck'),
      options: config
    };
  });

  return function processHealthcheckPlugin(_x7) {
    return _ref5.apply(this, arguments);
  };
})();

const porgPluginSchemaObject = _joi2.default.object().keys({
  type: _joi2.default.string().valid('user-session', 'static-bearer', 'no-auth').required(),
  key: _joi2.default.when('type', { is: 'static-bearer', then: _joi2.default.string().required() }),
  roles: _joi2.default.when('type', { is: 'user-session', then: _joi2.default.array().items(_joi2.default.string()).required() }),
  twoFactor: _joi2.default.when('type', { is: 'user-session', then: _joi2.default.boolean() })
});

const porgPluginSchema = _joi2.default.object().keys({
  'porg-auth': _joi2.default.alternatives().try(porgPluginSchemaObject, _joi2.default.array().items(porgPluginSchemaObject)).required()
});

const validatePluginAndRoutes = (() => {
  var _ref6 = _asyncToGenerator(function* (server) {
    const table = server.table();
    for (let route of table) {
      const validation = _joi2.default.validate(route.settings.plugins, porgPluginSchema);
      if (validation.error) {
        let message = `Error processing porg-auth in path ${route.path} method ${route.method} problem`;
        validation.error.details.forEach(function (e) {
          message += ` ${e.path[0]} => ${e.type}`;
        });
        throw new Error(message);
      }
      const porgPluginOptions = [].concat(validation.value['porg-auth']);
      if (!(0, _auth.hasUserSession)()) {
        porgPluginOptions.filter(function (o) {
          return o.type === 'user-session';
        }).map(function (o) {
          throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'user-session' was not defined in porg.yml`);
        });
      }
      if (!(0, _auth.hasStaticBearer)()) {
        porgPluginOptions.filter(function (o) {
          return o.type === 'static-bearer';
        }).map(function (o) {
          throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'static-bearer' was not defined in porg.yml`);
        });
      }

      if ((0, _auth.hasStaticBearer)()) {
        porgPluginOptions.filter(function (o) {
          return o.type === 'static-bearer';
        }).filter(function (o) {
          return !(0, _auth.hasStaticBearerKey)(o.key);
        }).map(function (o) {
          throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'static-bearer' key ${o.key} was not defined in porg.yml`);
        });
      }

      if ((0, _auth.hasUserSession)() && !(0, _auth.hasTwoFactor)()) {
        porgPluginOptions.filter(function (o) {
          return o.type === 'user-session' && o.twoFactor !== undefined;
        }).map(function (o) {
          throw new Error(`Error processing porg-auth in path ${route.path} method ${route.method} 'twoFactor' was not defined in porg.yml`);
        });
      }
    }
  });

  return function validatePluginAndRoutes(_x8) {
    return _ref6.apply(this, arguments);
  };
})();

exports.default = (() => {
  var _ref7 = _asyncToGenerator(function* ({ config }) {
    const server = createServer({ config });
    let plugins = [];
    plugins.push((yield processAuthPlugin({ server, config })));
    plugins.push((yield processLoggingPlugin({ server, config })));
    plugins.push((yield processMetricsPlugin({ server, config })));
    if (config.auth.userSession) {
      plugins.push((yield processHealthcheckPlugin({ server, config })));
    }
    plugins = plugins.concat((yield (0, _routes2.default)({ nodeStartPath: config.nodeStartPath })));
    for (let pluginConfig of config.plugins) {
      const plugin = { plugin: require(pluginConfig.name) };
      if (pluginConfig.options) {
        plugin.options = pluginConfig.options;
      }
      if (pluginConfig.routes) {
        plugin.routes = pluginConfig.routes;
      }
      if (pluginConfig.once) {
        plugin.once = pluginConfig.once;
      }
      plugins.push(plugin);
    }
    const internalPlugins = yield (0, _plugins2.default)({ nodeStartPath: config.nodeStartPath });
    plugins = plugins.concat(internalPlugins);
    yield server.register(plugins);
    server.ext({ type: 'onPreStart', method: validatePluginAndRoutes });
    return server;
  });

  return function (_x9) {
    return _ref7.apply(this, arguments);
  };
})();

module.exports = exports['default'];