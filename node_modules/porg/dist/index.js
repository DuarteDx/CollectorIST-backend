'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.porgFork = exports.tasks = exports.lockProvider = exports.getSocketIO = exports.Elasticsearch = exports.setConfig = exports.TestUtils = exports.StatusCodes = exports.clientProm = exports.loadMigrationFileStream = exports.loadMigrationFile = exports.errorWithKey = exports.setupError = exports.logger = exports.mapper = exports.Task = exports.Storage = exports.Email = exports.Smtp = exports.Mongo = exports.consoleFormat = exports.porg = exports.config = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _serverFactory = require('./serverFactory');

var _serverFactory2 = _interopRequireDefault(_serverFactory);

var _drivers = require('./drivers');

var _errors = require('./plugins/errors');

var _papagaio = require('papagaio');

var _migrations = require('./migrations');

var _Email = require('./emails/Email');

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _ConfigSchema = require('./config/ConfigSchema');

var _ConfigSchema2 = _interopRequireDefault(_ConfigSchema);

var _tasks = require('./tasks');

var _emails = require('./emails');

var _emails2 = _interopRequireDefault(_emails);

var _storage = require('./storage');

var _fileUploadHandlers = require('./file-upload-handlers');

var _Task = require('./tasks/Task');

var _Task2 = _interopRequireDefault(_Task);

var _schemas = require('./schemas');

var _cluster = require('cluster');

var _cluster2 = _interopRequireDefault(_cluster);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _metrics = require('./plugins/metrics');

var _StatusCodes = require('./utils/StatusCodes');

var _StatusCodes2 = _interopRequireDefault(_StatusCodes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _camelcaseKeys = require('camelcase-keys');

var _camelcaseKeys2 = _interopRequireDefault(_camelcaseKeys);

var _sockets = require('./sockets');

var _providers = require('./providers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

process.on('unhandledRejection', error => {
  // Will print "unhandledRejection err is not defined"
  (0, _papagaio.logger)(['porg', 'unhandledRejection', 'emerg'], `${error.message} - ${error.stack}`);
});

let config = null;
let lockProvider = null;

const setConfig = ({ basePath, redefine }) => {
  let papagaio = {};
  try {
    if (!redefine && config !== null) {
      throw new Error('Config already set');
    } else {
      exports.config = config = null;
    }
    // Get all Configuration paths
    let configurationPaths = [_path2.default.join(basePath, 'porg.yml')];
    // if (opts.configurationFile) {
    //   configurationPaths = [path.join(basePath, opts.configurationFile)]
    // } else if (opts.configurationFiles) {
    //   configurationPaths = opts.configurationFiles.map((el) => {
    //     return path.join(basePath, el)
    //   })
    // }
    // Merge all Configurations
    for (let item in configurationPaths) {
      if (!_fs2.default.existsSync(configurationPaths[item])) {
        throw new Error(`Missing configuration file at ${configurationPaths[item]}`);
      }
      try {
        exports.config = config = _extends({}, config, (0, _camelcaseKeys2.default)(_jsYaml2.default.safeLoad(_fs2.default.readFileSync(configurationPaths[item], 'utf8')), { deep: true }));
      } catch (err) {
        throw new Error('Error processing porg.yml: ' + err.message);
      }
    }

    const validation = _joi2.default.validate(config, _ConfigSchema2.default, {
      allowUnknown: true
    });
    if (validation.error) {
      throw new Error('Error processing options of porg.yml: ' + validation.error);
    }
    exports.config = config = validation.value;
    (0, _errors.resetMapErrors)();
    papagaio = config.papagaio;
  } catch (err) {
    throw err;
  } finally {
    (0, _papagaio.configLogger)(papagaio);
  }
};

const porgFork = (() => {
  var _ref = _asyncToGenerator(function* ({ porgYmlPath }) {
    setConfig({ basePath: porgYmlPath });
    const setupApplicationErrorsScriptPath = _path2.default.join(porgYmlPath, 'errors', 'index.js');
    if (_fs2.default.existsSync(setupApplicationErrorsScriptPath)) {
      const setupPorgErrors = require('./plugins/errors/internal-errors');
      const setupApplicationErrors = require(setupApplicationErrorsScriptPath);
      setupPorgErrors();
      setupApplicationErrors();
    }

    if (config.drivers) {
      for (let [driver, options] of Object.entries(config.drivers)) {
        (0, _drivers.runConfigWithDriver)({ driver, options });
      }
    }
    if (config.lockProvider) {
      exports.lockProvider = lockProvider = (0, _providers.getLockProvider)({ name: config.lockProvider.type });
    }

    if (config.email) {
      yield (0, _emails2.default)({
        emailConfig: config.email,
        nodeStartPath: porgYmlPath
      });
    }

    if (config.storage) {
      (0, _storage.storageSetup)({ storageConfig: config.storage });
    }
  });

  return function porgFork(_x) {
    return _ref.apply(this, arguments);
  };
})();

const porg = (() => {
  var _ref2 = _asyncToGenerator(function* (opts) {
    let configTasks;
    if (config === null) {
      setConfig({ basePath: _path2.default.dirname(require.main.filename) });
    }

    opts = opts || {};
    if (!opts.runOnce) {
      opts.runOnce = _asyncToGenerator(function* () {});
    }
    if (!opts.afterTasksStart) {
      opts.afterTasksStart = _asyncToGenerator(function* () {});
    }

    if (config.drivers) {
      for (let [driver, options] of Object.entries(config.drivers)) {
        (0, _drivers.runConfigWithDriver)({ driver, options });
      }
    }

    if (config.lockProvider) {
      exports.lockProvider = lockProvider = (0, _providers.getLockProvider)({ name: config.lockProvider.type });
    }

    if (config.email) {
      yield (0, _emails2.default)({
        emailConfig: config.email,
        nodeStartPath: config.nodeStartPath
      });
    }

    if (config.storage) {
      (0, _storage.storageSetup)({ storageConfig: config.storage });
    }
    if (config.tasks) {
      configTasks = yield (0, _tasks.configTaskRunner)({
        lockProviderName: config.lockProvider.type,
        persistentTaskProviderName: config.tasks.persistenceProvider,
        applicationName: config.application.name,
        nodeStartPath: config.nodeStartPath
      });
    }

    if (_cluster2.default.isMaster) {
      yield opts.runOnce();
      yield opts.afterTasksStart();
    }

    if (_cluster2.default.isMaster && (process.env.NODE_ENV === 'production' || config.application.forkInDevelopment)) {
      if (process.env.NODE_ENV === 'development') {
        _cluster2.default.setupMaster({
          execArgv: ['-r', 'babel-register']
        });
      }
      const numCPUs = _os2.default.cpus().length;
      for (let i = 0; i < numCPUs; i++) {
        _cluster2.default.fork();
      }
    } else {
      try {
        (0, _papagaio.logger)(['info', 'server', 'boot'], `${config.application.name} started.`);
        (0, _papagaio.logger)(['info', 'bootstrap', 'server'], `${config.application.name} API (Process: ${process.pid}) is now running on port ${config.application.backendPort}`);
        const server = yield (0, _serverFactory2.default)({ config });
        (0, _papagaio.logger)(['info', 'bootstrap', 'server'], `End server creation`);
        if (config.tasks) {
          yield (0, _tasks.setupTasksEndpoints)({
            server,
            config: config.tasks
          });
        }

        if (config.fileUploadHandlers) {
          yield (0, _fileUploadHandlers.setupFileUploadHandlers)({
            server,
            fileUploadHandlers: config.fileUploadHandlers
          });
        }
        return {
          getHapiServer: function () {
            return server;
          },
          start: (() => {
            var _ref5 = _asyncToGenerator(function* () {
              try {
                if (config.migrations) {
                  (0, _papagaio.logger)(['info', 'server', 'boot'], `Running any needed migrations`);
                  if (!config.lockProvider) {
                    throw new Error('A lock provider must be defined to run migrations');
                  }
                  yield (0, _migrations.runMigrations)({
                    lockProviderName: config.lockProvider.type,
                    migrationPersistenceProviderName: config.migrations.persistenceProvider,
                    applicationName: config.application.name,
                    nodeStartPath: config.nodeStartPath
                  });
                }
                if (config.tasks) {
                  yield configTasks.start();
                }
                yield server.start();
              } catch (error) {
                (0, _papagaio.logger)(['err', 'porg', 'bootstrap'], `${error.message} - ${error.stack}`);
              }
              if (config.websockets && config.websockets.enabled) {
                try {
                  (0, _papagaio.logger)(['info', 'porg', 'socket'], 'SocketIO enabled starting setup...');
                  yield (0, _sockets.setSocketIO)({ config, listener: server.listener });
                  (0, _papagaio.logger)(['info', 'porg', 'socket'], 'SocketIO started');
                } catch (err) {
                  (0, _papagaio.logger)(['err', 'bootstrap'], 'Error starting application');
                }
              }
              return server;
            });

            return function start() {
              return _ref5.apply(this, arguments);
            };
          })()
        };
      } catch (error) {
        (0, _papagaio.logger)(['err', 'porg', 'bootstrap'], `${error.message} - ${error.stack}`);
        process.exit(1);
      }
    }
  });

  return function porg(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

const cleanDbs = (() => {
  var _ref6 = _asyncToGenerator(function* ({ config }) {
    const validation = _joi2.default.validate(config, _ConfigSchema2.default, { allowUnknown: true });
    if (validation.error) {
      throw new Error(validation.error);
    }
    config = validation.value;
    try {
      for (let [driver, options] of Object.entries(config.drivers)) {
        const driverObject = (0, _drivers.runConfigWithDriver)({ driver, options });
        (0, _papagaio.logger)(['info', 'testing', 'migration'], `Cleanning database with driver ${driver} for tests`);
        yield driverObject.cleanDatabase();
      }
    } catch (err) {
      (0, _papagaio.logger)(['error', 'testing', 'migration'], err.message);
    }
  });

  return function cleanDbs(_x3) {
    return _ref6.apply(this, arguments);
  };
})();

const closeDbs = (() => {
  var _ref7 = _asyncToGenerator(function* ({ config }) {
    const validation = _joi2.default.validate(config, _ConfigSchema2.default, { allowUnknown: true });
    if (validation.error) {
      throw new Error(validation.error);
    }
    config = validation.value;
    try {
      for (let [driver, options] of Object.entries(config.drivers)) {
        const driverObject = (0, _drivers.runConfigWithDriver)({ driver, options });
        (0, _papagaio.logger)(['info', 'testing', 'migration'], `Close database with driver ${driver} for tests`);
        yield driverObject.shutdown();
      }
    } catch (err) {
      (0, _papagaio.logger)(['error', 'testing', 'migration'], err.message);
    }
  });

  return function closeDbs(_x4) {
    return _ref7.apply(this, arguments);
  };
})();

const TestUtils = {
  cleanDbs,
  closeDbs,
  path: relativePath => {
    const rootPath = process.env.PWD;
    if (relativePath.startsWith('@')) {
      return _path2.default.join(rootPath, relativePath.replace('@', ''));
    } else if (relativePath.startsWith('#')) {
      return _path2.default.join(rootPath, 'test', relativePath.replace('#', ''));
    } else {
      return relativePath;
    }
  }
};

exports.config = config;
exports.porg = porg;
exports.consoleFormat = _papagaio.consoleFormat;
exports.Mongo = _drivers.Mongo;
exports.Smtp = _drivers.Smtp;
exports.Email = _Email.Email;
exports.Storage = _storage.Storage;
exports.Task = _Task2.default;
exports.mapper = _schemas.mapper;
exports.logger = _papagaio.logger;
exports.setupError = _errors.setupError;
exports.errorWithKey = _errors.errorWithKey;
exports.loadMigrationFile = _migrations.loadFile;
exports.loadMigrationFileStream = _migrations.loadFileStream;
exports.clientProm = _metrics.clientProm;
exports.StatusCodes = _StatusCodes2.default;
exports.TestUtils = TestUtils;
exports.setConfig = setConfig;
exports.Elasticsearch = _drivers.Elasticsearch;
exports.getSocketIO = _sockets.getSocketIO;
exports.lockProvider = lockProvider;
exports.tasks = _tasks.tasks;
exports.porgFork = porgFork;