'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupTasksEndpoints = exports.configTaskRunner = exports.tasks = undefined;

var _papagaio = require('papagaio');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _Task = require('./Task');

var _Task2 = _interopRequireDefault(_Task);

var _providers = require('../providers');

var _index = require('../utils/index');

var _cronParser = require('cron-parser');

var _cronParser2 = _interopRequireDefault(_cronParser);

var _sha = require('sha1');

var _sha2 = _interopRequireDefault(_sha);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _loop = require('./loop');

var _loop2 = _interopRequireDefault(_loop);

var _GetDefinedTasks = require('./controllers/GetDefinedTasks');

var _GetDefinedTasks2 = _interopRequireDefault(_GetDefinedTasks);

var _GetInstanceTasks = require('./controllers/GetInstanceTasks');

var _GetInstanceTasks2 = _interopRequireDefault(_GetInstanceTasks);

var _GetInstanceTaskById = require('./controllers/GetInstanceTaskById');

var _GetInstanceTaskById2 = _interopRequireDefault(_GetInstanceTaskById);

var _CreateInstanceTask = require('./controllers/CreateInstanceTask');

var _CreateInstanceTask2 = _interopRequireDefault(_CreateInstanceTask);

var _CreateDefinedTask = require('./controllers/CreateDefinedTask');

var _CreateDefinedTask2 = _interopRequireDefault(_CreateDefinedTask);

var _UpdateInstanceTask = require('./controllers/UpdateInstanceTask');

var _UpdateInstanceTask2 = _interopRequireDefault(_UpdateInstanceTask);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const TASKS_FOLDER = 'tasks';
// Default max number of minutes a task will run
const EXECUTION_TIME_LIMIT = 2; // In minutes

const tasks = exports.tasks = {
  runTask: (() => {
    var _ref = _asyncToGenerator(function* ({ name, input }) {
      throw new Error('Tasks not defined in porg');
    });

    return function runTask(_x) {
      return _ref.apply(this, arguments);
    };
  })(),
  killTask: (() => {
    var _ref2 = _asyncToGenerator(function* ({ id }) {
      throw new Error('Tasks not defined in porg');
    });

    return function killTask(_x2) {
      return _ref2.apply(this, arguments);
    };
  })()
};

const configTaskRunner = exports.configTaskRunner = (() => {
  var _ref3 = _asyncToGenerator(function* ({ lockProviderName, persistentTaskProviderName, applicationName, nodeStartPath }) {
    (0, _papagaio.logger)(['info', 'tasks'], `Starting tasks config with ${persistentTaskProviderName}`);
    let dirMainFile = _path2.default.dirname(require.main.filename);
    if (nodeStartPath) {
      dirMainFile = _path2.default.resolve(dirMainFile, nodeStartPath);
    }
    let normalizePath = _path2.default.join(dirMainFile, TASKS_FOLDER);
    let lockProvider = (0, _providers.getLockProvider)({ name: lockProviderName });
    let persistentTaskProvider = (0, _providers.getPersistenceTaskProvider)({ name: persistentTaskProviderName });

    const sessionLoadTasks = yield lockProvider.createSession();
    const sessionRenewInterval = setInterval(_asyncToGenerator(function* () {
      yield sessionLoadTasks.renewSession();
    }), 5000);
    while (!(yield sessionLoadTasks.attemptLock({ lockId: 'tasks' }))) {
      yield (0, _index.sleep)(1000);
    }

    let tasksMap = new Map();
    const loadtasksPaths = [_path2.default.resolve(__dirname, './internal')];
    if (_fs2.default.existsSync(normalizePath)) {
      loadtasksPaths.push(normalizePath);
    } else {
      (0, _papagaio.logger)(['info', 'porg', 'tasks'], 'Porg could not find any tasks folder.');
    }

    try {
      for (let loadPath of loadtasksPaths) {
        for (let file of _fs2.default.readdirSync(loadPath)) {
          const filePath = _path2.default.join(loadPath, file);
          let loadedTask = require(filePath);
          let taskExecution = loadedTask.cron ? 'cron' : 'none';
          let TaskClass = loadedTask.default;
          let taskCronExpression = loadedTask.cron;
          let executionTimeLimit = loadedTask.timeLimitInMinutes ? loadedTask.timeLimitInMinutes : EXECUTION_TIME_LIMIT;
          let defaultInput;
          try {
            defaultInput = loadedTask.defaultInput ? JSON.stringify(loadedTask.defaultInput) : JSON.stringify({});
          } catch (err) {
            (0, _papagaio.logger)(['info', 'tasks'], `Error in default input ${file} converting to "{}"`);
            defaultInput = JSON.stringify({});
          }
          let execution;
          if (taskExecution === 'cron') {
            _cronParser2.default.parseExpression(taskCronExpression); // throws error if not a cron expression
            execution = 'cron';
          } else if (taskExecution === 'none') {
            execution = 'none';
          } else {
            throw new Error('Invalid execution option');
          }
          const src = _fs2.default.readFileSync(_path2.default.join(loadPath, file), 'utf8');
          let taskName = file.replace(/.js$/, '');
          let version = (0, _sha2.default)(String(taskName + src));
          if (_Task2.default.isPrototypeOf(TaskClass)) {
            (0, _papagaio.logger)(['info', 'tasks'], `Loading task ${taskName}`);
            // let task = new TaskClass({name: taskName, persistentTaskProvider})
            yield persistentTaskProvider.addTask({ taskName, execution, cron: taskCronExpression, version, executionTimeLimit, defaultInput });
            tasksMap.set(taskName, filePath);
          }
        }
      }
      yield sessionLoadTasks.releaseLock({ lockId: 'tasks' });
    } catch (err) {
      throw err;
    } finally {
      clearInterval(sessionRenewInterval);
      sessionLoadTasks.destroySession();
      (0, _papagaio.logger)(['info', 'tasks'], `Ending tasks config with ${persistentTaskProviderName}`);
    }

    tasks.runTask = (() => {
      var _ref5 = _asyncToGenerator(function* ({ name, input }) {
        const now = (0, _moment2.default)();
        const task = yield persistentTaskProvider.getTask({ taskName: name });
        const id = (0, _sha2.default)(String(task.id + now));
        try {
          if (input) {
            if (typeof input !== 'object') {
              throw new Error();
            }
            JSON.stringify(input); // Test if it is possible to stringify, to see if valid json
          } else {
            input = JSON.parse(task.defaultInput);
          }
        } catch (err) {
          input = {};
        }
        yield persistentTaskProvider.createTaskInstance({ id, name: task.id, date: now.valueOf(), executionTimeLimit: task.executionTimeLimit, input });
        return {
          getId() {
            return id;
          },
          kill() {
            var _this = this;

            return _asyncToGenerator(function* () {
              yield persistentTaskProvider.updateTaskInstance({ id: _this.getId(), killswitch: true });
            })();
          },
          updateExecutionTimeLimit(minutes) {
            var _this2 = this;

            return _asyncToGenerator(function* () {
              if (!(Number.isInteger(minutes) && minutes > 0)) {
                throw new Error('Minutes must be a integer greater than 0');
              }
              yield persistentTaskProvider.updateTaskInstance({ id: _this2.getId(), executionTimeLimit: minutes });
            })();
          },
          getInfo() {
            var _this3 = this;

            return _asyncToGenerator(function* () {
              return persistentTaskProvider.getTaskInstanceById({ id: _this3.getId() });
            })();
          }
        };
      });

      return function (_x4) {
        return _ref5.apply(this, arguments);
      };
    })();
    tasks.killTask = (() => {
      var _ref6 = _asyncToGenerator(function* ({ id }) {
        yield persistentTaskProvider.updateTaskInstance({ id, killswitch: true });
      });

      return function (_x5) {
        return _ref6.apply(this, arguments);
      };
    })();
    return {
      start: (() => {
        var _ref7 = _asyncToGenerator(function* () {
          (0, _loop2.default)({ persistentTaskProvider, lockProvider, tasksMap });
        });

        return function start() {
          return _ref7.apply(this, arguments);
        };
      })()
    };
  });

  return function configTaskRunner(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

const setupTasksEndpoints = exports.setupTasksEndpoints = (() => {
  var _ref8 = _asyncToGenerator(function* ({ server, config }) {
    let persistentTaskProvider = (0, _providers.getPersistenceTaskProvider)({ name: config.persistenceProvider });

    server.route({
      path: '/api/v1/tasks',
      method: 'GET',
      handler: _GetDefinedTasks2.default.handler({ persistentTaskProvider }),
      config: _GetDefinedTasks2.default.config(config)
    });

    server.route({
      path: '/api/v1/tasks',
      method: 'POST',
      handler: _CreateDefinedTask2.default.handler({ persistentTaskProvider }),
      config: _CreateDefinedTask2.default.config(config)
    });

    server.route({
      path: '/api/v1/tasks/{id}/instances',
      method: 'POST',
      handler: _CreateInstanceTask2.default.handler({ persistentTaskProvider }),
      config: _CreateInstanceTask2.default.config(config)
    });

    server.route({
      path: '/api/v1/tasks/{id}/instances',
      method: 'PUT',
      handler: _UpdateInstanceTask2.default.handler({ persistentTaskProvider }),
      config: _UpdateInstanceTask2.default.config(config)
    });

    server.route({
      path: '/api/v1/tasks-instances',
      method: 'GET',
      handler: _GetInstanceTasks2.default.handler({ persistentTaskProvider }),
      config: _GetInstanceTasks2.default.config(config)
    });

    server.route({
      path: '/api/v1/tasks-instances/{id}',
      method: 'GET',
      handler: _GetInstanceTaskById2.default.handler({ persistentTaskProvider }),
      config: _GetInstanceTaskById2.default.config(config)
    });
  });

  return function setupTasksEndpoints(_x6) {
    return _ref8.apply(this, arguments);
  };
})();