'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _child_process = require('child_process');

var _cronParser = require('cron-parser');

var _cronParser2 = _interopRequireDefault(_cronParser);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sha = require('sha1');

var _sha2 = _interopRequireDefault(_sha);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _StatusTask = require('./StatusTask');

var _StatusTask2 = _interopRequireDefault(_StatusTask);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } // import { logger } from 'papagaio'

// import { transform } from 'babel-core'
// import requireString from 'require-from-string'


// Time to check for new tasks to run, and to process cron expressions
const CHECK_TASK_INTERVAL = 1000; // Time miliseconds
// Number of tasks instance that should be created in advance for a cron expression
const NUMBER_OF_JOBS_FOR_TASK = 3;
// Max durantion of time between taskinstance.date and now, from where task shoud be ignored and not runned
const POINT_OF_NO_RETURN = 30; // In minutes
// Map of workers
const mapOfWorkers = new Map();

// const getClassTask = async ({persistentTaskProvider, tasksMap, name}) => {
//   let classObject = tasksMap.get(name)
//   if (classObject) {
//     return classObject
//   } else {
//     const task = await persistentTaskProvider.getTask({taskName: name})
//     const directory = path.join(__dirname, '../../.babelrc')
//     const { code } = transform(task.src, {extends: directory})
//     classObject = requireString(code)
//     const TaskClass = classObject.default
//     return new TaskClass({name})
//   }
// }

const killTask = (() => {
  var _ref = _asyncToGenerator(function* (taskInstanceId) {
    const infoWorker = mapOfWorkers.get(taskInstanceId);
    infoWorker.worker.kill('SIGKILL');
    yield infoWorker.session.releaseLock({ lockId: infoWorker.lockId });
    yield infoWorker.session.destroySession();
    clearInterval(infoWorker.sessionRenewInterval);
  });

  return function killTask(_x) {
    return _ref.apply(this, arguments);
  };
})();

const processClose = (() => {
  var _ref2 = _asyncToGenerator(function* ({ m, persistentTaskProvider, taskInstance }) {
    yield killTask(taskInstance.id);
    yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Completed, endDate: (0, _moment2.default)().valueOf() });
  });

  return function processClose(_x2) {
    return _ref2.apply(this, arguments);
  };
})();

const processUpdate = (() => {
  var _ref3 = _asyncToGenerator(function* ({ m, worker, persistentTaskProvider }) {
    yield persistentTaskProvider.updateTaskInstance(m.params);
  });

  return function processUpdate(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

const processAbort = (() => {
  var _ref4 = _asyncToGenerator(function* ({ m, persistentTaskProvider, taskInstance }) {
    yield killTask(taskInstance.id);
    yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Aborted, message: m.err, endDate: (0, _moment2.default)().valueOf() });
  });

  return function processAbort(_x4) {
    return _ref4.apply(this, arguments);
  };
})();

exports.default = ({ persistentTaskProvider, lockProvider, tasksMap }) => {
  setInterval(_asyncToGenerator(function* () {
    let sessionRenewInterval;

    // START - FIND TASKS AWAITING TO RUN AND RUN THEM
    const tasksInstances = yield persistentTaskProvider.getTasksInstances({ status: _StatusTask2.default.Pending });
    const now = (0, _moment2.default)();
    for (let taskInstance of tasksInstances) {
      let taskDate = (0, _moment2.default)(taskInstance.date);
      if (now.diff(taskDate) > 0) {
        let duration = _moment2.default.duration(now.diff(taskDate));
        const sessionRunTask = yield lockProvider.createSession();
        try {
          if (!(yield sessionRunTask.attemptLock({ lockId: `${taskInstance.name}-${taskInstance.id}` }))) {
            yield sessionRunTask.destroySession();
            continue;
          }
          sessionRenewInterval = setInterval(_asyncToGenerator(function* () {
            yield sessionRunTask.renewSession();
          }), 5000);
          const taskInLock = yield persistentTaskProvider.getTaskInstanceById({ id: taskInstance.id });
          if (taskInLock.status === _StatusTask2.default.Pending) {
            if (duration.asMinutes() > POINT_OF_NO_RETURN) {
              yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Aborted, message: `Point of no return: ${duration.asMinutes()} limit ${POINT_OF_NO_RETURN}` });
            } else {
              const taskPath = tasksMap.get(taskInstance.name);
              const taskInfo = yield persistentTaskProvider.getTask({ taskName: taskInstance.name });
              const worker = (0, _child_process.fork)(_path2.default.join(__dirname, '/fork.js'), [`${taskInstance.name}-${taskInstance.id}`], {
                execArgv: ['-r', 'babel-register']
              });
              mapOfWorkers.set(taskInstance.id, { worker, session: sessionRunTask, lockId: `${taskInstance.name}-${taskInstance.id}`, sessionRenewInterval });
              worker.on('message', (() => {
                var _ref7 = _asyncToGenerator(function* (m) {
                  switch (m.type) {
                    case 'close':
                      yield processClose({ m, persistentTaskProvider, taskInstance });
                      break;
                    case 'update':
                      yield processUpdate({ m, persistentTaskProvider });
                      break;
                    case 'abort':
                      yield processAbort({ m, persistentTaskProvider, taskInstance });
                      break;
                    default:
                      throw new Error('invalid type');
                  }
                });

                return function (_x5) {
                  return _ref7.apply(this, arguments);
                };
              })());
              const sessionId = sessionRunTask.getSessionId();
              worker.send({ type: 'init', instanceId: taskInstance.id, porgYmlPath: _path2.default.dirname(require.main.filename), taskPath, taskInfo, input: taskInstance.input, sessionId });
            }
          }
        } catch (err) {
          clearInterval(sessionRenewInterval);
          sessionRunTask.destroySession();
          throw err;
        }
      }
    }
    // END - FIND TASKS AWAITING TO RUN AND RUN THEM

    // START - FIND TASKS WITH A CRON AND CREATE INSTANCES TASKS
    const sessionFindNewTasks = yield lockProvider.createSession();
    try {
      sessionRenewInterval = setInterval(function () {
        sessionFindNewTasks.renewSession();
      }, 5000);
      if (!(yield sessionFindNewTasks.attemptLock({ lockId: 'tasks-list' }))) {
        clearInterval(sessionRenewInterval);
        sessionFindNewTasks.destroySession();
        return;
      }
      const tasks = yield persistentTaskProvider.getTasks();
      for (let task of tasks) {
        if (task.execution === 'cron') {
          const tasksInstances = yield persistentTaskProvider.getTaskInstances({ name: task.id, status: _StatusTask2.default.Pending });
          if (tasksInstances.length < NUMBER_OF_JOBS_FOR_TASK) {
            const currentTime = tasksInstances.length === 0 ? (0, _moment2.default)().valueOf() : (0, _moment2.default)(tasksInstances[tasksInstances.length - 1].date).valueOf();
            const numberOfNewInstancesForTask = NUMBER_OF_JOBS_FOR_TASK - tasksInstances.length;
            const interval = _cronParser2.default.parseExpression(task.cron, { currentDate: currentTime });
            for (let n = 0; n < numberOfNewInstancesForTask; ++n) {
              let taskTime = (0, _moment2.default)(interval.next().getTime());
              yield persistentTaskProvider.createTaskInstance({ id: (0, _sha2.default)(String(task.id + taskTime)), name: task.id, date: taskTime.toDate(), executionTimeLimit: task.executionTimeLimit, input: JSON.parse(task.defaultInput) });
            }
          }
        }
      }
      sessionFindNewTasks.releaseLock({ lockId: 'tasks-list' });
      sessionFindNewTasks.destroySession();
      clearInterval(sessionRenewInterval);
    } catch (err) {
      clearInterval(sessionRenewInterval);
      sessionFindNewTasks.destroySession();
      throw err;
    }
    // END - FIND TASKS WITH A CRON AND CREATE INSTANCES TASKS

    // START - FIND TASKS RUNNING AND KILL THEM IF TIME LIMIT EXCEDED
    const sessionTimeLimitTasks = yield lockProvider.createSession();
    try {
      sessionRenewInterval = setInterval(function () {
        sessionTimeLimitTasks.renewSession();
      }, 5000);
      if (!(yield sessionTimeLimitTasks.attemptLock({ lockId: 'tasks-time-limit' }))) {
        clearInterval(sessionRenewInterval);
        sessionTimeLimitTasks.destroySession();
        return;
      }

      const tasksInstances = yield persistentTaskProvider.getTasksInstances({ status: _StatusTask2.default.Running });
      const now = (0, _moment2.default)();
      for (let taskInstance of tasksInstances) {
        const startDate = (0, _moment2.default)(taskInstance.startDate);
        const durantionTask = _moment2.default.duration(now.diff(startDate));
        if (durantionTask.asMinutes() > taskInstance.executionTimeLimit) {
          const worker = mapOfWorkers.get(taskInstance.id);
          if (worker) {
            yield killTask(taskInstance.id);
            yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Aborted, message: 'Time limit Exceded', endDate: (0, _moment2.default)().valueOf() });
            continue;
          }
        }
        if (durantionTask.asMinutes() > taskInstance.executionTimeLimit + 60) {
          yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Aborted, message: 'Time limit Exceded (no worker killed)', endDate: (0, _moment2.default)().valueOf() });
          continue;
        }

        if (taskInstance.killswitch) {
          const worker = mapOfWorkers.get(taskInstance.id);
          if (worker) {
            yield killTask(taskInstance.id);
            yield persistentTaskProvider.updateTaskInstance({ id: taskInstance.id, status: _StatusTask2.default.Aborted, message: 'Killed by administrator', endDate: (0, _moment2.default)().valueOf() });
          }
        }
      }

      sessionTimeLimitTasks.releaseLock({ lockId: 'tasks-time-limit' });
      sessionTimeLimitTasks.destroySession();
      clearInterval(sessionRenewInterval);
    } catch (err) {
      clearInterval(sessionRenewInterval);
      sessionTimeLimitTasks.destroySession();
      throw err;
    }
    // END -  FIND TASKS RUNNING AND KILL THEM IF TIME LIMIT EXCEDED
  }), CHECK_TASK_INTERVAL);
};

module.exports = exports['default'];