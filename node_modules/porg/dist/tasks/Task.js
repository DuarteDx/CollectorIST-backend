'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('./../');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const mapLocks = lockMap => {
  const locks = {};
  for (const [key, value] of lockMap.entries()) {
    locks[key] = value;
  }
  return locks;
};
class Task {
  constructor({ name }) {
    this.name = name;
    this.running = false;
  }

  run() {
    return _asyncToGenerator(function* () {
      throw new Error('You need to extend Task class');
    })();
  }

  execute({ id, input, sessionId }) {
    var _this = this;

    return _asyncToGenerator(function* () {
      try {
        _this.id = id;
        _this.text = '';
        _this.running = true;
        _this.lockMap = new Map();
        _this.session = yield _.lockProvider.getSession({ id: sessionId });
        yield _this.progress(0);
        yield _this.run(input);
        yield _this.progress(100);
        yield _this.flushPrint();
        _this.running = false;
        const nOpenLocks = Array.from(_this.lockMap.values()).filter(function (a) {
          return a;
        }).length;
        if (nOpenLocks > 0) {
          yield _this.releaseAllLocks();
          process.send({ type: 'abort', err: 'Task ended with open locks' });
        } else {
          process.send({ type: 'close' });
        }
      } catch (err) {
        yield _this.releaseAllLocks();
        if (err.key) {
          const tags = err.getTags();
          let message = '[ ';
          for (let n = 0; n < tags.length; ++n) {
            message += tags[n];
            message += tags.length - 1 === n ? ' ]' : ', ';
          }
          message += ' ' + (err.getCause() ? err.getCause() : err.key);
          _this.println(message);
          const metadata = err.getMetadata();
          for (const key in metadata) {
            _this.println(`    ${key}:${metadata[key]}`);
          }
          _this.println(err.stack);
          yield _this.flushPrint();
          process.send({ type: 'abort', err: 'Application error with key: ' + err.key });
        } else {
          _this.println(err.stack);
          yield _this.flushPrint();
          process.send({ type: 'abort', err: err.message });
        }
      }
    })();
  }

  progress(percentage) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (!_this2.running) {
        throw new Error('This method can only be called when task is running');
      }
      process.send({ type: 'update', params: { id: _this2.id, percentage } });
    })();
  }

  println(text) {
    this.print(text + '\n');
  }

  print(text) {
    if (!this.running) {
      throw new Error('This method can only be called when task is running');
    }
    this.text += text;
  }

  clear() {
    this.text = '';
  }

  lock(tag) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (_this3.lockMap.has(tag) && _this3.lockMap.get(tag)) {
        throw new Error(`Can't lock tag ${tag} because task ${_this3.id} already has the lock`);
      } else {
        if (yield _this3.session.attemptLock({ lockId: `porg-tag-${tag}` })) {
          _this3.lockMap.set(tag, true);
          process.send({ type: 'update', params: { id: _this3.id, locks: mapLocks(_this3.lockMap) } });
          return true;
        } else {
          return false;
        }
      }
    })();
  }

  hasLock(tag) {
    return this.lockMap.has(tag);
  }

  unlock(tag) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      if (_this4.lockMap.has(tag)) {
        yield _this4.session.releaseLock({ lockId: `porg-tag-${tag}` });
        _this4.lockMap.set(tag, false);
        process.send({ type: 'update', params: { id: _this4.id, locks: mapLocks(_this4.lockMap) } });
        return true;
      } else {
        throw new Error(`Can't unlock tag ${tag} because task ${_this4.id} doesn't has lock`);
      }
    })();
  }

  releaseAllLocks() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      for (const [lockTag, lockOpen] of _this5.lockMap.entries()) {
        if (lockOpen) {
          yield _this5.unlock(lockTag);
        }
      }
    })();
  }

  flushPrint() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      if (!_this6.running) {
        throw new Error('This method can only be called when task is running');
      }
      process.send({ type: 'update', params: { id: _this6.id, text: _this6.text } });
    })();
  }
}
exports.default = Task;
module.exports = exports['default'];