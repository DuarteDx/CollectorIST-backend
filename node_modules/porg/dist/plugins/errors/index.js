'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetMapErrors = exports.setupErrorInternal = exports.configLogger = exports.setupError = exports.logger = exports.errorWithKey = exports.plugin = undefined;

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _papagaio = require('papagaio');

var _internalErrors = require('./internal-errors');

var _internalErrors2 = _interopRequireDefault(_internalErrors);

var _v = require('uuid/v1');

var _v2 = _interopRequireDefault(_v);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const noSetupErrors = setupError => {
  (0, _papagaio.logger)(['info', 'papagaio'], 'No error setup function was provided...');
};

let errorMap = {};

class Arrrggg extends Error {
  constructor({ key, tags, cause, statusCode, metadata, ctx, stack }) {
    super(cause);
    this.key = key;
    this.statusCode = statusCode;
    this.cause = cause;
    this.stack = stack;
    this.ctx = ctx;
    this.metadata = metadata;
    this.tags = tags;
  }

  getTags() {
    return this.tags;
  }

  getKey() {
    return this.key;
  }

  getStatusCode() {
    return this.statusCode;
  }

  getCause() {
    return this.cause;
  }

  // Ctx to help string templating of the error message
  getCtx() {
    return this.ctx;
  }

  // Metadata goes to logs
  getMetadata() {
    return this.metadata;
  }
}

const hasLogLevelInArray = tags => {
  for (let tag of tags) {
    if (_papagaio.levels[tag] !== undefined) {
      return true;
    }
  }
  return false;
};

const setupError = ({ key, statusCode, translations }) => {
  if (statusCode < 400 || statusCode >= 500) {
    throw new Error('SetupError can only be used for 400 status code');
  }
  errorMap[key] = {
    translations,
    error: ({ tags, ctx, metadata, cause, stack }) => {
      tags.push(key);
      if (!hasLogLevelInArray(tags)) {
        tags.push('info');
      }
      const message = stack ? `${cause || key}\n${stack}` : cause || key;
      (0, _papagaio.logger)(tags, message, metadata);
      return new Arrrggg({
        tags,
        key,
        ctx,
        metadata,
        cause,
        statusCode,
        stack
      });
    }
  };
};

const setupErrorInternal = ({ key }) => {
  errorMap[key] = {
    translations: {
      en: 'Internal Server Error',
      pt: 'Erro Interno'
    },
    error: ({ tags, ctx, metadata, cause, stack }) => {
      tags.push(key);
      if (!hasLogLevelInArray(tags)) {
        tags.push('alert');
      }
      const hash = (0, _v2.default)();
      ctx = ctx || {};
      metadata = metadata || {};
      ctx['$error_hash'] = hash;
      metadata['$error_hash'] = hash;
      const message = stack ? `${cause || key}\n${stack}` : cause || key;
      (0, _papagaio.logger)(tags, message, metadata);
      return new Arrrggg({
        tags,
        key: 'internal-error',
        ctx,
        metadata,
        cause,
        stack,
        statusCode: 500
      });
    }
  };
};

const errorWithKey = (key, params) => {
  const errorEntry = errorMap[key];
  if (typeof params !== 'object' || !(params.tags instanceof Array)) {
    params = { tags: [] };
  }
  if (errorEntry) {
    if (!params.stack && !params.stackDisabled) {
      const myObject = new Error(key);
      Error.captureStackTrace(myObject, errorWithKey);
      params.stack = myObject.stack;
    }
    return errorEntry.error(params);
  } else {
    throw new Error(`No error was defined for key ${key}`);
  }
};

const schema = _joi2.default.object().keys({
  urlPath: _joi2.default.string().default('/api/v1/errors'),
  papagaio: _joi2.default.object().default({}),
  setupApplicationErrors: _joi2.default.func().default(noSetupErrors)
});

const errorSchema = _joi2.default.object().keys({
  error: _joi2.default.any().optional(),
  key: _joi2.default.string().required(),
  ctx: _joi2.default.object().default({}),
  metadata: _joi2.default.object().default({}),
  cause: _joi2.default.string().default('An unknown error has occurred'),
  statusCode: _joi2.default.number().integer().required()
});

const plugin = {
  name: 'errors-plugin',
  version: '1.0.0',
  register: (() => {
    var _ref = _asyncToGenerator(function* (server, options) {
      (0, _papagaio.logger)(['info', 'server', 'logging'], `Init config logging`);
      const validation = _joi2.default.validate(options, schema);
      if (validation.error) {
        throw new Error(validation.error);
      }

      (0, _internalErrors2.default)();
      const optionsErrors = validation.value;
      optionsErrors.setupApplicationErrors();

      const handleError = function (error, h) {
        try {
          if (error.output && error.output.statusCode === 404) {
            // Handles error throwed by hapi when a route doesn't exist
            error = errorWithKey('_route-not-found', { tags: ['porg', 'warn'], ctx: {}, cause: `Route not found: ${h.request.method.toUpperCase()}: ${h.request.url.path}`, stackDisabled: true });
          } else if (!(error instanceof Arrrggg)) {
            // Handles unhandled errors errors
            error = errorWithKey('internal-error', { tags: ['porg', 'emerg'], ctx: {}, cause: error.message, stack: error.stack });
          }

          const validation = _joi2.default.validate(error, errorSchema, { stripUnknown: true });
          if (validation.error) {
            error = errorWithKey('errors-error', { tags: ['porg', 'emerg'], ctx: {}, cause: error.message });
            return h.response({ key: error.key, ctx: error.ctx }).code(error.statusCode);
          } else {
            return h.response({ key: validation.value.key, ctx: validation.value.ctx }).code(validation.value.statusCode);
          }
        } catch (err) {
          (0, _papagaio.logger)(['emerg', 'log'], err.message);
        }
      };

      server.route({
        path: optionsErrors.urlPath,
        method: 'GET',
        handler: (() => {
          var _ref2 = _asyncToGenerator(function* (request, h) {
            const result = {};
            Object.keys(errorMap).forEach(function (key) {
              result[key] = errorMap[key].translations[request.query.lang];
            });
            return result;
          });

          return function handler(_x3, _x4) {
            return _ref2.apply(this, arguments);
          };
        })(),
        config: {
          validate: {
            query: {
              lang: _joi2.default.string().valid(['pt', 'en']).default('pt')
            }
          },
          plugins: {
            'porg-auth': {
              type: 'no-auth'
            }
          }
        }
      });

      const preResponse = function (request, h) {
        if (request.response instanceof Error) {
          return handleError(request.response, h);
        } else {
          return h.continue;
        }
      };
      server.ext('onPreResponse', preResponse);
      (0, _papagaio.logger)(['info', 'server', 'logging'], `End config logging`);
    });

    return function register(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })()
};

const resetMapErrors = () => {
  errorMap = {};
};

exports.plugin = plugin;
exports.errorWithKey = errorWithKey;
exports.logger = _papagaio.logger;
exports.setupError = setupError;
exports.configLogger = _papagaio.configLogger;
exports.setupErrorInternal = setupErrorInternal;
exports.resetMapErrors = resetMapErrors;