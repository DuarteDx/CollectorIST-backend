'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = exports.hasTwoFactor = exports.hasStaticBearerKey = exports.hasStaticBearer = exports.hasUserSession = exports.validateUserSessionCookies = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _errors = require('../errors');

var _papagaio = require('papagaio');

var _CasTicketValidation = require('./controllers/cas/CasTicketValidation');

var _CasTicketValidation2 = _interopRequireDefault(_CasTicketValidation);

var _RedirectToCas = require('./controllers/cas/RedirectToCas');

var _RedirectToCas2 = _interopRequireDefault(_RedirectToCas);

var _LogoutFromCAS = require('./controllers/cas/LogoutFromCAS');

var _LogoutFromCAS2 = _interopRequireDefault(_LogoutFromCAS);

var _SamlMetadata = require('./controllers/saml/SamlMetadata');

var _SamlMetadata2 = _interopRequireDefault(_SamlMetadata);

var _SamlRedirect = require('./controllers/saml/SamlRedirect');

var _SamlRedirect2 = _interopRequireDefault(_SamlRedirect);

var _SamlValidate = require('./controllers/saml/SamlValidate');

var _SamlValidate2 = _interopRequireDefault(_SamlValidate);

var _SamlLogout = require('./controllers/saml/SamlLogout');

var _SamlLogout2 = _interopRequireDefault(_SamlLogout);

var _SAMLUtils = require('./services/SAMLUtils');

var _SAMLUtils2 = _interopRequireDefault(_SAMLUtils);

var _GetU2FRegistrationChallenge = require('./controllers/u2f/GetU2FRegistrationChallenge');

var _GetU2FRegistrationChallenge2 = _interopRequireDefault(_GetU2FRegistrationChallenge);

var _SubmitU2FRegistrationChallenge = require('./controllers/u2f/SubmitU2FRegistrationChallenge');

var _SubmitU2FRegistrationChallenge2 = _interopRequireDefault(_SubmitU2FRegistrationChallenge);

var _GetU2FSignChallenge = require('./controllers/u2f/GetU2FSignChallenge');

var _GetU2FSignChallenge2 = _interopRequireDefault(_GetU2FSignChallenge);

var _SubmitU2FSignChallenge = require('./controllers/u2f/SubmitU2FSignChallenge');

var _SubmitU2FSignChallenge2 = _interopRequireDefault(_SubmitU2FSignChallenge);

var _RegisterTOTPSecretController = require('./controllers/totp/RegisterTOTPSecretController');

var _RegisterTOTPSecretController2 = _interopRequireDefault(_RegisterTOTPSecretController);

var _ConfirmTOTPRegistrationController = require('./controllers/totp/ConfirmTOTPRegistrationController');

var _ConfirmTOTPRegistrationController2 = _interopRequireDefault(_ConfirmTOTPRegistrationController);

var _SubmitTOTPChallengeController = require('./controllers/totp/SubmitTOTPChallengeController');

var _SubmitTOTPChallengeController2 = _interopRequireDefault(_SubmitTOTPChallengeController);

var _Logout2FA = require('./controllers/common/Logout2FA');

var _Logout2FA2 = _interopRequireDefault(_Logout2FA);

var _errors2 = require('./errors');

var _errors3 = _interopRequireDefault(_errors2);

var _JwtUtils = require('./services/JwtUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

let validateUserSessionCookies = exports.validateUserSessionCookies = function () {
  return false;
};

const DSIAuthScheme = (server, options) => {
  const getAuthType = function () {
    return this.auth.credentials.type;
  };
  const getPrincipal = function () {
    if (this.auth.isAuthenticated && this.auth.credentials.type === 'user-session') {
      const principal = _extends({}, this.auth.credentials, {
        username: this.auth.credentials.sub
      });
      delete principal.sub;
      if (principal.iat) {
        delete principal.iat;
      }
      if (principal.exp) {
        delete principal.exp;
      }
      return principal;
    } else {
      throw new Error('You must be in user-session');
    }
  };
  const principalHasRole = function (role) {
    if (this.auth.isAuthenticated && this.auth.credentials.type === 'user-session') {
      return this.auth.credentials.roles && this.auth.credentials.roles.includes(role);
    } else {
      throw new Error('You must be in user-session');
    }
  };
  const hasTwoFactor = function () {
    return !!this.auth.credentials.twoFactor;
  };

  exports.validateUserSessionCookies = validateUserSessionCookies = (() => {
    var _ref = _asyncToGenerator(function* ({ request, jwtToken, authConfig }) {
      const regularExpressionJwt = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
      if (!regularExpressionJwt.test(jwtToken)) {
        return null;
      }
      const auth = yield (0, _JwtUtils.jwtVerify)({ authorization: jwtToken, options, authConfig });
      const requiredRoles = authConfig && authConfig.roles || options.defaultRequiredRoles;
      const roles = auth.credentials && auth.credentials.roles ? auth.credentials.roles : [];
      const missingRoles = _underscore2.default.difference(requiredRoles, roles);
      if (request && request.auth.error instanceof Error) {
        throw request.auth.error;
      }
      if (missingRoles.length > 0) {
        throw (0, _errors.errorWithKey)('not-authorized', {
          ctx: {}
        });
      }
      auth.credentials.type = 'user-session';
      return auth;
    });

    return function validateUserSessionCookies(_x) {
      return _ref.apply(this, arguments);
    };
  })();

  server.decorate('request', 'getAuthType', getAuthType);
  server.decorate('request', 'getPrincipal', getPrincipal);
  server.decorate('request', 'principalHasRole', principalHasRole);
  server.decorate('request', 'hasTwoFactor', hasTwoFactor);

  return {
    authenticate: (() => {
      var _ref2 = _asyncToGenerator(function* (request, h) {
        let authConfigurations = [];
        let pluginConfiguration = request.route.settings.plugins['porg-auth'];
        if (!pluginConfiguration) {
          throw new Error('No porg auth in route');
        } else {
          authConfigurations = authConfigurations.concat(pluginConfiguration);
        }
        let type = 'not-authenticated';
        let ctx = {};
        let auth = {};
        for (let item in authConfigurations) {
          const authConfig = authConfigurations[item];
          switch (authConfig.type) {
            case 'user-session':
              if (!hasUserSession()) {
                throw new Error('This porg configuration doesnt support auth with user-session');
              }
              try {
                const jwtToken = request.state['P_SESSION'];
                auth = yield validateUserSessionCookies({ request, jwtToken, authConfig });
                if (!auth) {
                  continue;
                }
              } catch (err) {
                // If not authorized it must send message
                // Should be refactor to see if there is other authentication schema
                if (err.key === 'not-authorized') {
                  throw err;
                }
                type = err;
                continue;
              }
              return h.authenticated(auth);
            case 'static-bearer':
              if (!hasStaticBearer()) {
                throw new Error('This porg configuration doesnt support auth with static-bearer');
              }
              if (!authConfig.key) {
                throw new Error('A key must be defined when using static-bearer');
              }
              if (`Bearer ${options.staticBearer[authConfig.key]}` === request.raw.req.headers.authorization) {
                auth = {
                  credentials: {
                    type: 'static-bearer',
                    key: authConfig.key
                  }
                };
                return h.authenticated(auth);
              }
              break;
            case 'no-auth':
              return h.authenticated({ credentials: { type: 'no-auth' } });
            default:
              type = 'unknown-auth-type';
              ctx = {
                type: authConfig.type
              };
          }
        }
        throw (0, _errors.errorWithKey)(type, { ctx });
      });

      return function authenticate(_x2, _x3) {
        return _ref2.apply(this, arguments);
      };
    })()
  };
};

const getCasOptions = options => {
  return {
    serverUrl: options.cas.serverUrl,
    serviceUrl: options.cas.localAppUrl + options.cas.ticketValidationEndpointPath,
    protocolVersion: options.cas.protocolVersion,
    method: options.cas.requestMethod,
    useGateway: options.cas.asGateway,
    strictSSL: options.cas.strictSSL
  };
};

const setAuthRedirectEndpoint = (server, options) => {
  let handler, config, logoutHandler, logoutConfig;
  if (options.cas) {
    handler = _RedirectToCas2.default.handler(getCasOptions(options));
    config = _RedirectToCas2.default.config;
    logoutHandler = _LogoutFromCAS2.default.handler(getCasOptions(options));
    logoutConfig = _LogoutFromCAS2.default.config;
  } else {
    const samlOptions = _extends({
      serviceUrl: options.saml.localAppUrl
    }, (0, _SAMLUtils2.default)({
      sp: {
        assertUrl: options.saml.localAppUrl + '/api/v1/saml/validate',
        metadataUrl: options.saml.localAppUrl + '/api/v1/saml/metadata',
        privateKeyPath: options.saml.spPrivateKeyPath,
        certificatePath: options.saml.spCertificatePath
      },
      idp: {
        loginUrl: options.saml.loginUrl,
        logoutUrl: options.saml.logoutUrl,
        certificatePath: options.saml.idpCertificatePath
      }
    }));
    handler = _SamlRedirect2.default.handler({ samlOptions });
    config = _SamlRedirect2.default.config;
    logoutHandler = _SamlLogout2.default.handler({ samlOptions });
    logoutConfig = _SamlLogout2.default.config;
  }
  server.route({
    method: 'GET',
    path: options.redirectEndpointPath,
    handler,
    config
  });

  server.route({
    path: '/api/v1/logout',
    method: 'GET',
    handler: logoutHandler,
    config: logoutConfig
  });
};

const setupCASEndpoints = (server, options) => {
  const casOptions = getCasOptions(options);

  server.route({
    method: 'GET',
    path: _path2.default.join(options.cas.ticketValidationEndpointPath, '{callback}'),
    handler: _CasTicketValidation2.default.handler(casOptions, options),
    config: _CasTicketValidation2.default.config
  });
};

const setupSamlEndpoints = (server, options) => {
  const samlOptions = _extends({
    serviceUrl: options.saml.localAppUrl,
    logoutRedirect: options.saml.logoutRedirect
  }, (0, _SAMLUtils2.default)({
    sp: {
      assertUrl: options.saml.localAppUrl + '/api/v1/saml/validate',
      metadataUrl: options.saml.localAppUrl + '/api/v1/saml/metadata',
      privateKeyPath: options.saml.spPrivateKeyPath,
      certificatePath: options.saml.spCertificatePath
    },
    idp: {
      loginUrl: options.saml.loginUrl,
      logoutUrl: options.saml.logoutUrl,
      certificatePath: options.saml.idpCertificatePath
    }
  }));

  server.route({
    method: 'GET',
    path: '/api/v1/saml/metadata',
    handler: _SamlMetadata2.default.handler({ samlOptions, options }),
    config: _SamlMetadata2.default.config
  });

  server.route({
    method: 'GET',
    path: '/api/v1/saml/validate',
    handler: _SamlLogout2.default.handler({ samlOptions }),
    config: _SamlLogout2.default.config
  });

  server.route({
    method: 'POST',
    path: '/api/v1/saml/validate',
    handler: _SamlValidate2.default.handler({ samlOptions, options }),
    config: _SamlValidate2.default.config
  });

  server.route({
    method: 'GET',
    path: '/api/v1/saml/logout',
    handler: _SamlLogout2.default.handler({ samlOptions, options }),
    config: _SamlLogout2.default.config
  });
};

const setupTOTPEndpoints = (server, options) => {
  if (options.twoFactor.totp) {
    server.route({
      path: '/api/v1/totp-registration',
      method: 'POST',
      handler: _RegisterTOTPSecretController2.default.handler(options),
      config: _RegisterTOTPSecretController2.default.config
    });

    server.route({
      path: '/api/v1/totp-confirmation',
      method: 'POST',
      handler: _ConfirmTOTPRegistrationController2.default.handler(options),
      config: _ConfirmTOTPRegistrationController2.default.config
    });

    server.route({
      path: '/api/v1/totp-challenge',
      method: 'POST',
      handler: _SubmitTOTPChallengeController2.default.handler(options),
      config: _SubmitTOTPChallengeController2.default.config
    });
  }
};

const setupTwoFactorEndPoints = (server, options) => {
  if (options.twoFactor.u2f) {
    server.route({
      path: '/api/v1/u2f-registration',
      method: 'GET',
      handler: _GetU2FRegistrationChallenge2.default.handler(options),
      config: _GetU2FRegistrationChallenge2.default.config
    });

    server.route({
      path: '/api/v1/u2f-registration',
      method: 'POST',
      handler: _SubmitU2FRegistrationChallenge2.default.handler(options),
      config: _SubmitU2FRegistrationChallenge2.default.config
    });

    server.route({
      path: '/api/v1/u2f-sign-challenge',
      method: 'GET',
      handler: _GetU2FSignChallenge2.default.handler(options),
      config: _GetU2FSignChallenge2.default.config
    });

    server.route({
      path: '/api/v1/u2f-sign-challenge',
      method: 'POST',
      handler: _SubmitU2FSignChallenge2.default.handler(options),
      config: _SubmitU2FSignChallenge2.default.config
    });
  }
};

let hasUserSession = exports.hasUserSession = () => {
  throw new Error('hasUserSession is not defined');
};

let hasStaticBearer = exports.hasStaticBearer = () => {
  throw new Error('hasStaticBearer is not defined');
};

let hasStaticBearerKey = exports.hasStaticBearerKey = key => {
  throw new Error('getStaticBearerKeys is not defined');
};

let hasTwoFactor = exports.hasTwoFactor = () => {
  throw new Error('hasTwoFactor is not defined');
};

const plugin = exports.plugin = {
  name: 'auth-plugin',
  version: '1.0.0',
  register: (() => {
    var _ref3 = _asyncToGenerator(function* (server, options) {
      try {
        (0, _papagaio.logger)(['info', 'server', 'porg-auth'], `Init config porg-auth`);
        const optionsSchema = _joi2.default.object().keys({
          staticBearer: _joi2.default.object().pattern(/^/, _joi2.default.string()),
          redirectEndpointPath: _joi2.default.string().regex(/^\/[\w\W\/]+\/?$/).default('/api/v1/authenticate'),
          unauthorizedPath: _joi2.default.string().default('/unauthorized'),
          cas: {
            serverUrl: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            protocolVersion: _joi2.default.number().valid([1, 2, 3]).default(2.0),
            requestMethod: _joi2.default.string().valid(['GET', 'POST']).default('GET'),
            asGateway: _joi2.default.boolean().default(false),
            localAppUrl: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            ticketValidationEndpointPath: _joi2.default.string().regex(/^\/[\w\W\/]+\/?$/).default('/api/v1/cas-st-handler'),
            strictSSL: _joi2.default.boolean().default(true),
            saveRawCAS: _joi2.default.boolean().default(false)
          },
          saml: {
            localAppUrl: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            loginUrl: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            logoutUrl: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            logoutRedirect: _joi2.default.string().uri({ scheme: ['http', 'https'] }).required(),
            spCertificatePath: _joi2.default.string().required(),
            spPrivateKeyPath: _joi2.default.string().required(),
            idpCertificatePath: _joi2.default.string().required()
          },
          autoRegister: _joi2.default.boolean().default(true),
          sessionTime: _joi2.default.number().default(3600),
          jwt: {
            getPayloadForUsername: _joi2.default.func().required(),
            secret: _joi2.default.string().required()
          },
          defaultRequiredRoles: _joi2.default.array().default([]),
          twoFactor: {
            sessionTime: _joi2.default.number().default(1200),
            u2f: _joi2.default.object().keys({
              appId: _joi2.default.string().required(),
              getUserU2F: _joi2.default.func().required(),
              saveUserU2FChallenge: _joi2.default.func().required(),
              upsertUserU2F: _joi2.default.func().required()
            }),
            totp: _joi2.default.object().keys({
              service: _joi2.default.string().required(),
              getUserTOTP: _joi2.default.func().required(),
              confirmUserTOTP: _joi2.default.func().required(),
              upsertUserTOTP: _joi2.default.func().required(),
              digits: _joi2.default.number().integer().valid([6, 8]).default(6)
            })
          }
        });
        (0, _errors3.default)();
        const validation = _joi2.default.validate(options, optionsSchema);
        if (validation.error) {
          throw new Error(validation.error);
        }

        exports.hasUserSession = hasUserSession = function () {
          return (validation.value.cas !== undefined || validation.value.saml !== undefined) && validation.value.jwt !== undefined;
        };

        exports.hasStaticBearer = hasStaticBearer = function () {
          return validation.value.staticBearer !== undefined;
        };
        exports.hasStaticBearerKey = hasStaticBearerKey = function (key) {
          return Object.keys(validation.value.staticBearer).includes(key);
        };
        exports.hasTwoFactor = hasTwoFactor = function () {
          return !!validation.value.twoFactor;
        };
        server.auth.scheme('dsi-auth-scheme', DSIAuthScheme);
        if (validation.value.autoRegister) {
          server.auth.strategy('dsi-auth', 'dsi-auth-scheme', validation.value);
          if (hasUserSession()) {
            setAuthRedirectEndpoint(server, validation.value);
            if (validation.value.cas) {
              setupCASEndpoints(server, validation.value);
            } else {
              setupSamlEndpoints(server, validation.value);
            }

            if (hasTwoFactor()) {
              setupTOTPEndpoints(server, validation.value);
              setupTwoFactorEndPoints(server, validation.value);
              server.route({
                path: '/api/v1/logout/2fa',
                method: 'GET',
                handler: _Logout2FA2.default.handler(validation.value),
                config: _Logout2FA2.default.config
              });
            }
          }
        }
        (0, _papagaio.logger)(['info', 'server', 'porg-auth'], `End config porg-auth`);
      } catch (err) {
        (0, _papagaio.logger)(['err', 'server', 'porg-auth'], err.message);
      }
    });

    return function register(_x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  })()
};