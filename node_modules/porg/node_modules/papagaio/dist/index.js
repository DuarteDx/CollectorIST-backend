'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.consoleFormat = exports.levels = exports.configLogger = exports.logger = undefined;

var _winston = require('winston');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _winstonDailyRotateFile = require('winston-daily-rotate-file');

var _winstonDailyRotateFile2 = _interopRequireDefault(_winstonDailyRotateFile);

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

var _winstonTransport = require('winston-transport');

var _winstonTransport2 = _interopRequireDefault(_winstonTransport);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _stripAnsi = require('strip-ansi');

var _stripAnsi2 = _interopRequireDefault(_stripAnsi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let modernSyslog;

if (!/^win/i.test(process.platform)) {
  modernSyslog = require('modern-syslog');
}

let $logger = {
  log: () => {
    throw new Error('You need to call configLogger(config), before using logger');
  }
};

const levels = {
  emerg: 0,
  alert: 1,
  crit: 2,
  err: 3,
  warn: 4,
  notice: 5,
  info: 6,
  debug: 7
};

class SyslogTransport extends _winstonTransport2.default {
  constructor(opts) {
    super(opts);
    modernSyslog && modernSyslog.open(opts.ident, {}, modernSyslog.LOG_LOCAL0);
  }
  log(info, callback) {
    setImmediate(() => {
      this.emit('logged', info);
    });
    const level = levels[info.level] === undefined ? 3 : levels[info.level];
    modernSyslog && modernSyslog.log(level, info.message, callback);
  }
}

const consoleFormat = {
  convertToString(message) {
    let msg = '';
    if (message.tags) {
      msg = '[';
      for (let n = 0; n < message.tags.length; ++n) {
        msg += ` ${message.tags[n]}`;
        if (n + 1 !== message.tags.length) {
          msg += ',';
        }
      }
      msg += ' ]';
      msg = _chalk2.default.bold.italic(msg);
    }
    msg += ` ${message.msg}`;
    if (message.ctx) {
      for (let key in message.ctx) {
        msg += `${_os2.default.EOL}    ${key}: ${message.ctx[key]}`;
      }
    }
    return msg;
  },
  convertToJSON(message) {
    const json = {};
    message = (0, _stripAnsi2.default)(message);
    let tags = message.match(/\[ (.*) \]/)[1];
    tags = tags.split(', ');
    json.tags = tags;
    const match = message.match(/\[ .*\] (.*)/);
    json.msg = match[1];
    const ctxLines = message.substring(match[0].length + _os2.default.EOL.length);
    if (ctxLines) {
      let ctxArray = ctxLines.match(/^ {3}(.*)$/gm);
      const ctx = {};
      ctxArray = ctxArray.map(c => c.substring(4));
      for (let el of ctxArray) {
        el = el.split(': ');
        ctx[el[0]] = el[1];
      }
      json.ctx = ctx;
    }
    return json;
  }
};

class ConsoleTransport extends _winstonTransport2.default {
  log(info, callback) {
    setImmediate(() => {
      this.emit('logged', info);
    });
    const message = JSON.parse(info.message);

    const intersection = _underscore2.default.intersection(message.tags, Object.keys(levels));
    if (intersection.length > 0) {
      switch (intersection[0]) {
        case 'emerg':
          console.log(_chalk2.default.redBright(consoleFormat.convertToString(message)));
          break;
        case 'alert':
          console.log(_chalk2.default.redBright(consoleFormat.convertToString(message)));
          break;
        case 'crit':
          console.log(_chalk2.default.red(consoleFormat.convertToString(message)));
          break;
        case 'err':
          console.log(_chalk2.default.red(consoleFormat.convertToString(message)));
          break;
        case 'warn':
          console.log(_chalk2.default.yellowBright(consoleFormat.convertToString(message)));
          break;
        case 'notice':
          console.log(_chalk2.default.yellow(consoleFormat.convertToString(message)));
          break;
        case 'info':
          console.log(_chalk2.default.green(consoleFormat.convertToString(message)));
          break;
        case 'debug':
          console.log(_chalk2.default.blue(consoleFormat.convertToString(message)));
          break;
        default:
          console.log(_chalk2.default.gray(consoleFormat.convertToString(message)));
      }
    } else {
      console.log(_chalk2.default.gray(consoleFormat.convertToString(message)));
    }
    callback();
  }
}

const configLogger = config => {
  const configSchema = {
    loggers: _joi2.default.array().items(_joi2.default.object().keys({
      type: _joi2.default.string().valid(['console', 'file-rotate', 'file', 'syslog']),
      level: _joi2.default.string().valid(Object.keys(levels)).default('info'),
      options: _joi2.default.object().when('type', {
        is: 'console',
        then: _joi2.default.any().forbidden()
      }).when('type', {
        is: 'file',
        then: _joi2.default.object().keys({
          filename: _joi2.default.string().required()
        })
      }).when('type', {
        is: 'file-rotate',
        then: _joi2.default.object().keys({
          datePattern: _joi2.default.string().default('yyyy-MM-dd'),
          filename: _joi2.default.string().required()
        })
      }).when('type', {
        is: 'syslog',
        then: _joi2.default.object().keys({
          ident: _joi2.default.string().default('node-app')
        })
      })
    })).default([])
  };

  const validation = _joi2.default.validate(config, configSchema, { allowUnknown: true });
  if (validation.error) {
    throw new Error(`Invalid options: ${validation.error}`);
  } else {
    config = validation.value;
  }
  const loggers = config && config.loggers && config.loggers.length > 0 ? config.loggers : [{ type: 'console' }];
  const transportsList = loggers.map(loggerConfig => {
    switch (loggerConfig.type) {
      case 'console':
        return new ConsoleTransport({ level: loggerConfig.level });
      case 'file':
        return new _winston.transports.File({ filename: `${loggerConfig.options.filename}.log`, level: loggerConfig.level });
      case 'file-rotate':
        return new _winstonDailyRotateFile2.default({
          filename: loggerConfig.options.filename + '-%DATE%.log',
          datePattern: loggerConfig.options.datePattern,
          prepend: true,
          level: loggerConfig.logLevel
        });
      case 'syslog':
        return new SyslogTransport({
          level: loggerConfig.level,
          ident: loggerConfig.options.ident
        });
    }
  });
  $logger = (0, _winston.createLogger)({
    levels,
    transports: transportsList
  });
};

const logger = (tags, msg, ctx) => {
  const config = {
    tags,
    msg,
    ctx
  };
  const configSchema = _joi2.default.object().keys({
    tags: _joi2.default.array().items(_joi2.default.string()).required(),
    msg: _joi2.default.string().required(),
    ctx: _joi2.default.object().pattern(/^[a-zA-Z$][a-zA-Z0-9_-]*$/, _joi2.default.string().required())
  });

  const validation = _joi2.default.validate(config, configSchema);
  let message;
  if (validation.error) {
    throw new Error(`Invalid options for log: ${validation.error}`);
  } else {
    message = validation.value;
  }
  const intersection = _underscore2.default.intersection(tags, Object.keys(levels));
  let selectedLogger;
  if (intersection.length === 0) {
    selectedLogger = 'debug';
  } else if (intersection.length > 1) {
    $logger.log({ level: 4,
      message: JSON.stringify({
        tags: ['papagaio', 'warn'],
        message: `Log levels conflict ${intersection} when logged withs: ${tags}. Using ${intersection[0]}`
      }) });
    selectedLogger = intersection[0];
  } else {
    selectedLogger = intersection[0];
  }
  return $logger.log({ level: selectedLogger, message: JSON.stringify(message) });
};

exports.logger = logger;
exports.configLogger = configLogger;
exports.levels = levels;
exports.consoleFormat = consoleFormat;